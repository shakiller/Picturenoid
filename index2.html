<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <title>Игра с физикой отскоков</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    body {
      background: linear-gradient(135deg, #1a2a6c, #b21f1f, #fdbb2d);
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      color: white;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 20px;
    }
    .container {
      max-width: 1000px;
      width: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 20px;
    }
    header {
      text-align: center;
      margin-bottom: 20px;
    }
    h1 {
      font-size: 2.5rem;
      margin-bottom: 10px;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
    }
    .game-area {
      display: flex;
      gap: 20px;
      width: 100%;
      flex-wrap: wrap;
      justify-content: center;
    }
    .game-container {
      position: relative;
      background: #222;
      border-radius: 10px;
      overflow: hidden;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
    }
    canvas {
      display: block;
      background: #111;
    }
    .ui-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
    }
    .stats {
      position: absolute;
      top: 15px;
      left: 15px;
      background: rgba(0, 0, 0, 0.7);
      padding: 10px 15px;
      border-radius: 8px;
      font-size: 1.1rem;
    }
    .controls {
      display: flex;
      gap: 15px;
      margin-top: 20px;
    }
    button {
      padding: 12px 25px;
      background: #4a4af0;
      color: white;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-size: 1rem;
      font-weight: bold;
      transition: all 0.3s;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
    }
    button:hover {
      background: #5a5aff;
      transform: translateY(-2px);
    }
    button:active {
      transform: translateY(1px);
    }
    button#pauseBtn.paused {
      background: #f04a4a;
    }
    button#pauseBtn.paused:hover {
      background: #ff5a5a;
    }
    .level-selector {
      background: rgba(255, 255, 255, 0.1);
      padding: 20px;
      border-radius: 10px;
      width: 300px;
    }
    .level-selector h2 {
      margin-bottom: 15px;
      text-align: center;
    }
    .level-list {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    .level-item {
      padding: 12px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.3s;
    }
    .level-item:hover {
      background: rgba(255, 255, 255, 0.2);
    }
    .level-item.active {
      background: #4a4af0;
    }
    .instructions {
      background: rgba(255, 255, 255, 0.1);
      padding: 20px;
      border-radius: 10px;
      margin-top: 20px;
      max-width: 800px;
    }
    .instructions h2 {
      margin-bottom: 10px;
    }
    .instructions ul {
      margin-left: 20px;
    }
    .instructions li {
      margin-bottom: 8px;
    }
    .game-over {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.85);
      padding: 30px;
      border-radius: 10px;
      text-align: center;
      display: none;
    }
    .game-over h2 {
      font-size: 2.5rem;
      margin-bottom: 15px;
    }
    .game-over p {
      font-size: 1.2rem;
      margin-bottom: 20px;
    }
    @media (max-width: 768px) {
      .game-area {
        flex-direction: column;
        align-items: center;
      }
      .level-selector {
        width: 100%;
        max-width: 400px;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>Физика Отскоков</h1>
      <p>Шарик отскакивает от фигур с реалистичной физикой!</p>
    </header>
    
    <div class="game-area">
      <div class="game-container">
        <canvas id="gameCanvas" width="600" height="500"></canvas>
        <div class="ui-overlay">
          <div class="stats">
            <div>Столкновений: <span id="collisionCount">0</span></div>
            <div>Осталось фигур: <span id="remainingShapes">0</span></div>
            <div>Счет: <span id="score">0</span></div>
          </div>
        </div>
        <div class="game-over" id="gameOver">
          <h2>Уровень пройден!</h2>
          <p>Фигур разрушено: <span id="destroyedCount">0</span></p>
          <p>Счет: <span id="finalScore">0</span></p>
          <button id="nextLevelBtn">Следующий уровень</button>
        </div>
      </div>
      
      <div class="level-selector">
        <h2>Выбор уровня</h2>
        <div class="level-list" id="levelList">
          <!-- Уровни будут загружены через JS -->
        </div>
        <div class="controls">
          <button id="resetBtn">Перезапуск</button>
          <button id="pauseBtn">Пауза</button>
        </div>
      </div>
    </div>
    
    <div class="instructions">
      <h2>Как играть:</h2>
      <ul>
        <li>Шарик автоматически движется и отскакивает от фигур</li>
        <li>Каждое столкновение с фигурой разрушает её и приносит очки</li>
        <li>Разные фигуры имеют разную прочность и дают разное количество очков</li>
        <li>Цель - разрушить все фигуры на уровне</li>
        <li>Используйте кнопки для управления игрой</li>
      </ul>
    </div>
  </div>

  <script>
    // Уровни игры
    const levels = {
      "level1": {
        name: "Хаски",
        ball: {
          radius: 8,
          initialPosition: {x: 100, y: 100},
          initialVelocity: {x: 4, y: 3}
        },
        shapes: [
          {
            type: "polygon",
            id: "left_ear_outer",
            points: [
              {x: 70, y: 40},
              {x: 100, y: -20},
              {x: 130, y: 40}
            ],
            color: "#999",
            health: 1,
            score: 10
          },
          {
            type: "polygon",
            id: "left_ear_inner",
            points: [
              {x: 85, y: 30},
              {x: 100, y: -5},
              {x: 115, y: 30}
            ],
            color: "pink",
            health: 1,
            score: 15
          },
          {
            type: "polygon",
            id: "right_ear_outer",
            points: [
              {x: 470, y: 40},
              {x: 440, y: -20},
              {x: 410, y: 40}
            ],
            color: "#999",
            health: 1,
            score: 10
          },
          {
            type: "polygon",
            id: "right_ear_inner", 
            points: [
              {x: 455, y: 30},
              {x: 440, y: -5},
              {x: 425, y: 30}
            ],
            color: "pink",
            health: 1,
            score: 15
          },
          {
            type: "circle",
            id: "head",
            x: 300,
            y: 120,
            radius: 80,
            color: "#fff",
            health: 2,
            score: 20
          },
          {
            type: "ellipse",
            id: "mask",
            x: 300,
            y: 120,
            radiusX: 50,
            radiusY: 80,
            color: "#999",
            health: 2,
            score: 25
          },
          {
            type: "ellipse",
            id: "left_eye",
            x: 270,
            y: 110,
            radiusX: 10,
            radiusY: 15,
            color: "#000",
            health: 1,
            score: 5
          },
          {
            type: "ellipse",
            id: "right_eye",
            x: 330,
            y: 110,
            radiusX: 10,
            radiusY: 15,
            color: "#000",
            health: 1,
            score: 5
          },
          {
            type: "circle",
            id: "nose",
            x: 300,
            y: 145,
            radius: 8,
            color: "#000",
            health: 3,
            score: 30
          },
          {
            type: "arc",
            id: "tongue",
            x: 300,
            y: 165,
            radiusX: 12,
            radiusY: 8,
            startAngle: 0,
            endAngle: Math.PI,
            color: "pink",
            health: 1,
            score: 10
          },
          {
            type: "ellipse",
            id: "body",
            x: 300,
            y: 250,
            radiusX: 70,
            radiusY: 50,
            color: "#ccc",
            health: 3,
            score: 30
          },
          {
            type: "ellipse", 
            id: "left_paw",
            x: 260,
            y: 300,
            radiusX: 20,
            radiusY: 12,
            color: "#fff",
            health: 2,
            score: 15
          },
          {
            type: "ellipse",
            id: "right_paw",
            x: 340,
            y: 300,
            radiusX: 20,
            radiusY: 12,
            color: "#fff",
            health: 2,
            score: 15
          },
          {
            type: "ellipse",
            id: "tail",
            x: 370,
            y: 270,
            radiusX: 30,
            radiusY: 15,
            rotation: -0.5,
            color: "#ccc",
            health: 2,
            score: 20
          }
        ],
        bounds: {
          left: 0,
          top: 0,
          right: 600,
          bottom: 500,
          bounceFactor: 0.95
        }
      },
      "level2": {
        name: "Геометрические фигуры",
        ball: {
          radius: 8,
          initialPosition: {x: 100, y: 100},
          initialVelocity: {x: 5, y: 4}
        },
        shapes: [
          {
            type: "circle",
            id: "circle1",
            x: 150,
            y: 150,
            radius: 40,
            color: "#ff4444",
            health: 2,
            score: 20
          },
          {
            type: "circle",
            id: "circle2",
            x: 450,
            y: 150,
            radius: 40,
            color: "#44ff44",
            health: 2,
            score: 20
          },
          {
            type: "ellipse",
            id: "ellipse1",
            x: 300,
            y: 100,
            radiusX: 60,
            radiusY: 30,
            color: "#4444ff",
            health: 3,
            score: 30
          },
          {
            type: "polygon",
            id: "triangle",
            points: [
              {x: 200, y: 300},
              {x: 300, y: 200},
              {x: 400, y: 300}
            ],
            color: "#ffff44",
            health: 2,
            score: 25
          },
          {
            type: "polygon",
            id: "pentagon",
            points: [
              {x: 100, y: 350},
              {x: 150, y: 300},
              {x: 200, y: 350},
              {x: 175, y: 400},
              {x: 125, y: 400}
            ],
            color: "#ff44ff",
            health: 3,
            score: 35
          },
          {
            type: "polygon",
            id: "hexagon",
            points: [
              {x: 400, y: 350},
              {x: 450, y: 320},
              {x: 500, y: 350},
              {x: 500, y: 400},
              {x: 450, y: 430},
              {x: 400, y: 400}
            ],
            color: "#44ffff",
            health: 3,
            score: 35
          }
        ],
        bounds: {
          left: 0,
          top: 0,
          right: 600,
          bottom: 500,
          bounceFactor: 0.95
        }
      },
      "level3": {
        name: "Случайные препятствия",
        ball: {
          radius: 8,
          initialPosition: {x: 300, y: 400},
          initialVelocity: {x: 4, y: -5}
        },
        shapes: [
          {
            type: "circle",
            id: "c1",
            x: 100,
            y: 100,
            radius: 25,
            color: "#ff6666",
            health: 1,
            score: 10
          },
          {
            type: "circle",
            id: "c2",
            x: 500,
            y: 100,
            radius: 25,
            color: "#66ff66",
            health: 1,
            score: 10
          },
          {
            type: "circle",
            id: "c3",
            x: 100,
            y: 400,
            radius: 25,
            color: "#6666ff",
            health: 1,
            score: 10
          },
          {
            type: "circle",
            id: "c4",
            x: 500,
            y: 400,
            radius: 25,
            color: "#ffff66",
            health: 1,
            score: 10
          },
          {
            type: "ellipse",
            id: "e1",
            x: 300,
            y: 150,
            radiusX: 80,
            radiusY: 20,
            color: "#ff66ff",
            health: 2,
            score: 20
          },
          {
            type: "ellipse",
            id: "e2",
            x: 300,
            y: 350,
            radiusX: 80,
            radiusY: 20,
            color: "#66ffff",
            health: 2,
            score: 20
          },
          {
            type: "polygon",
            id: "p1",
            points: [
              {x: 200, y: 200},
              {x: 250, y: 250},
              {x: 200, y: 300},
              {x: 150, y: 250}
            ],
            color: "#ff9966",
            health: 2,
            score: 25
          },
          {
            type: "polygon",
            id: "p2",
            points: [
              {x: 400, y: 200},
              {x: 450, y: 250},
              {x: 400, y: 300},
              {x: 350, y: 250}
            ],
            color: "#99ff66",
            health: 2,
            score: 25
          }
        ],
        bounds: {
          left: 0,
          top: 0,
          right: 600,
          bottom: 500,
          bounceFactor: 0.95
        }
      }
    };

    // Класс для обработки физики
    class PhysicsEngine {
      // Столкновение круга с кругом
      circleCircleCollision(ball, circle) {
        const dx = ball.x - circle.x;
        const dy = ball.y - circle.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        return distance < (ball.radius + circle.radius);
      }

      // Столкновение круга с эллипсом
      circleEllipseCollision(ball, ellipse) {
        // Учет поворота эллипса
        const cos = Math.cos(ellipse.rotation || 0);
        const sin = Math.sin(ellipse.rotation || 0);
        
        const dx = ball.x - ellipse.x;
        const dy = ball.y - ellipse.y;
        
        // Поворот координат в систему эллипса
        const rotatedX = dx * cos + dy * sin;
        const rotatedY = -dx * sin + dy * cos;
        
        // Проверка столкновения
        const normalized = (rotatedX * rotatedX) / (ellipse.radiusX * ellipse.radiusX) + 
                          (rotatedY * rotatedY) / (ellipse.radiusY * ellipse.radiusY);
        
        return normalized <= 1 + (ball.radius / Math.min(ellipse.radiusX, ellipse.radiusY));
      }

      // Столкновение круга с полигоном
      circlePolygonCollision(ball, polygon) {
        for (let i = 0; i < polygon.points.length; i++) {
          const p1 = polygon.points[i];
          const p2 = polygon.points[(i + 1) % polygon.points.length];
          
          // Проверка столкновения с ребром
          if (this.circleLineCollision(ball, p1, p2)) {
            return true;
          }
        }
        return false;
      }

      // Столкновение круга с отрезком
      circleLineCollision(ball, p1, p2) {
        // Вектор отрезка
        const lineVec = { x: p2.x - p1.x, y: p2.y - p1.y };
        // Вектор от начала отрезка к центру шара
        const ballVec = { x: ball.x - p1.x, y: ball.y - p1.y };
        
        const lineLengthSquared = lineVec.x * lineVec.x + lineVec.y * lineVec.y;
        const dotProduct = ballVec.x * lineVec.x + ballVec.y * lineVec.y;
        
        let t = Math.max(0, Math.min(1, dotProduct / lineLengthSquared));
        
        // Ближайшая точка на отрезке
        const closestPoint = {
          x: p1.x + t * lineVec.x,
          y: p1.y + t * lineVec.y
        };
        
        // Расстояние до ближайшей точки
        const dx = ball.x - closestPoint.x;
        const dy = ball.y - closestPoint.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        return distance < ball.radius;
      }

      // Столкновение круга с дугой (упрощенно как с эллипсом)
      circleArcCollision(ball, arc) {
        // Для упрощения считаем дугу как часть эллипса
        const ellipse = {
          x: arc.x,
          y: arc.y,
          radiusX: arc.radiusX,
          radiusY: arc.radiusY,
          rotation: arc.rotation || 0
        };
        
        if (!this.circleEllipseCollision(ball, ellipse)) {
          return false;
        }
        
        // Проверяем, что точка касания находится в пределах углов дуги
        const angle = Math.atan2(ball.y - arc.y, ball.x - arc.x);
        const normalizedAngle = angle < 0 ? angle + 2 * Math.PI : angle;
        
        return normalizedAngle >= arc.startAngle && normalizedAngle <= arc.endAngle;
      }

      // Расчет нормали отскока
      calculateBounceNormal(ball, shape) {
        let normal = { x: 0, y: 0 };
        
        switch (shape.type) {
          case 'circle':
            const dx = ball.x - shape.x;
            const dy = ball.y - shape.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            normal = { x: dx / distance, y: dy / distance };
            break;
            
          case 'ellipse':
          case 'arc':
            // Для эллипса/дуги нормаль зависит от положения точки касания
            const cos = Math.cos(shape.rotation || 0);
            const sin = Math.sin(shape.rotation || 0);
            const localX = (ball.x - shape.x) * cos + (ball.y - shape.y) * sin;
            const localY = -(ball.x - shape.x) * sin + (ball.y - shape.y) * cos;
            
            const gradientX = (2 * localX) / (shape.radiusX * shape.radiusX);
            const gradientY = (2 * localY) / (shape.radiusY * shape.radiusY);
            
            // Поворот нормали обратно в глобальную систему
            normal = {
              x: gradientX * cos - gradientY * sin,
              y: gradientX * sin + gradientY * cos
            };
            
            const length = Math.sqrt(normal.x * normal.x + normal.y * normal.y);
            normal.x /= length;
            normal.y /= length;
            break;
            
          case 'polygon':
            // Для полигона находим ближайшее ребро
            let minDistance = Infinity;
            for (let i = 0; i < shape.points.length; i++) {
              const p1 = shape.points[i];
              const p2 = shape.points[(i + 1) % shape.points.length];
              
              const edge = { x: p2.x - p1.x, y: p2.y - p1.y };
              const toBall = { x: ball.x - p1.x, y: ball.y - p1.y };
              
              const edgeLength = Math.sqrt(edge.x * edge.x + edge.y * edge.y);
              const edgeNormal = { x: -edge.y / edgeLength, y: edge.x / edgeLength };
              
              const distance = Math.abs(toBall.x * edgeNormal.x + toBall.y * edgeNormal.y);
              
              if (distance < minDistance) {
                minDistance = distance;
                normal = edgeNormal;
                
                // Проверяем направление нормали
                const dot = toBall.x * edgeNormal.x + toBall.y * edgeNormal.y;
                if (dot < 0) {
                  normal.x = -normal.x;
                  normal.y = -normal.y;
                }
              }
            }
            break;
        }
        
        return normal;
      }

      // Обработка отскока
      handleBounce(ball, shape, normal) {
        const dotProduct = ball.vx * normal.x + ball.vy * normal.y;
        
        // Коэффициент отскока зависит от типа фигуры
        const bounceFactor = shape.bounceFactor || 0.8;
        
        ball.vx = ball.vx - 2 * dotProduct * normal.x * bounceFactor;
        ball.vy = ball.vy - 2 * dotProduct * normal.y * bounceFactor;
        
        // Коррекция позиции чтобы избежать залипания
        const overlap = ball.radius + 2;
        
        ball.x += normal.x * overlap;
        ball.y += normal.y * overlap;
      }
    }

    // Основной класс игры
    class Game {
      constructor(canvas) {
        this.canvas = canvas;
        this.ctx = canvas.getContext('2d');
        this.physics = new PhysicsEngine();
        this.isPaused = false;
        this.currentLevel = 'level1';
        this.score = 0;
        
        // Загрузка уровня
        this.loadLevel(this.currentLevel);
        
        // Инициализация шарика
        this.resetBall();
        
        // Статистика
        this.collisionCount = 0;
        
        // Запуск игрового цикла
        this.lastTime = 0;
        this.animate(0);
        
        // Обработчики событий
        this.setupEventListeners();
      }
      
      loadLevel(levelId) {
        this.currentLevel = levelId;
        const level = levels[levelId];
        
        // Копируем фигуры, чтобы не изменять оригинальные данные
        this.shapes = JSON.parse(JSON.stringify(level.shapes));
        
        // Добавляем здоровье и активность
        this.shapes.forEach(shape => {
          shape.initialHealth = shape.health;
          shape.active = true;
        });
        
        this.bounds = level.bounds;
        this.levelName = level.name;
        
        // Сброс шарика
        this.resetBall();
        
        // Обновление UI
        this.updateUI();
        
        // Скрыть экран завершения игры
        document.getElementById('gameOver').style.display = 'none';
      }
      
      resetBall() {
        const level = levels[this.currentLevel];
        this.ball = {
          x: level.ball.initialPosition.x,
          y: level.ball.initialPosition.y,
          vx: level.ball.initialVelocity.x,
          vy: level.ball.initialVelocity.y,
          radius: level.ball.radius
        };
      }
      
      setupEventListeners() {
        document.getElementById('resetBtn').addEventListener('click', () => {
          this.resetBall();
          this.loadLevel(this.currentLevel);
          this.score = 0;
          this.collisionCount = 0;
          this.updateUI();
        });
        
        document.getElementById('pauseBtn').addEventListener('click', () => {
          this.togglePause();
        });
        
        document.getElementById('nextLevelBtn').addEventListener('click', () => {
          const levelIds = Object.keys(levels);
          const currentIndex = levelIds.indexOf(this.currentLevel);
          const nextIndex = (currentIndex + 1) % levelIds.length;
          this.loadLevel(levelIds[nextIndex]);
          this.updateLevelList();
        });
        
        // Инициализация списка уровней
        this.updateLevelList();
      }
      
      updateLevelList() {
        const levelList = document.getElementById('levelList');
        levelList.innerHTML = '';
        
        Object.keys(levels).forEach(levelId => {
          const level = levels[levelId];
          const levelItem = document.createElement('div');
          levelItem.className = 'level-item';
          if (levelId === this.currentLevel) {
            levelItem.classList.add('active');
          }
          levelItem.textContent = level.name;
          levelItem.addEventListener('click', () => {
            this.loadLevel(levelId);
            this.updateLevelList();
          });
          levelList.appendChild(levelItem);
        });
      }
      
      togglePause() {
        this.isPaused = !this.isPaused;
        const pauseBtn = document.getElementById('pauseBtn');
        
        if (this.isPaused) {
          pauseBtn.textContent = 'Продолжить';
          pauseBtn.classList.add('paused');
        } else {
          pauseBtn.textContent = 'Пауза';
          pauseBtn.classList.remove('paused');
          this.animate(0);
        }
      }
      
      update(deltaTime) {
        if (this.isPaused) return;
        
        // Движение шара
        this.ball.x += this.ball.vx;
        this.ball.y += this.ball.vy;

        // Проверка столкновений с границами
        if (this.ball.x - this.ball.radius < this.bounds.left) {
          this.ball.vx = Math.abs(this.ball.vx) * this.bounds.bounceFactor;
          this.ball.x = this.bounds.left + this.ball.radius;
          this.collisionCount++;
        } else if (this.ball.x + this.ball.radius > this.bounds.right) {
          this.ball.vx = -Math.abs(this.ball.vx) * this.bounds.bounceFactor;
          this.ball.x = this.bounds.right - this.ball.radius;
          this.collisionCount++;
        }
        
        if (this.ball.y - this.ball.radius < this.bounds.top) {
          this.ball.vy = Math.abs(this.ball.vy) * this.bounds.bounceFactor;
          this.ball.y = this.bounds.top + this.ball.radius;
          this.collisionCount++;
        } else if (this.ball.y + this.ball.radius > this.bounds.bottom) {
          this.ball.vy = -Math.abs(this.ball.vy) * this.bounds.bounceFactor;
          this.ball.y = this.bounds.bottom - this.ball.radius;
          this.collisionCount++;
        }

        // Проверка столкновений с фигурами
        let collisionOccurred = false;
        
        for (let i = 0; i < this.shapes.length; i++) {
          const shape = this.shapes[i];
          if (!shape.active) continue;
          
          let collision = false;
          let normal = { x: 0, y: 0 };

          switch (shape.type) {
            case 'circle':
              collision = this.physics.circleCircleCollision(this.ball, shape);
              break;
            case 'ellipse':
              collision = this.physics.circleEllipseCollision(this.ball, shape);
              break;
            case 'polygon':
              collision = this.physics.circlePolygonCollision(this.ball, shape);
              break;
            case 'arc':
              collision = this.physics.circleArcCollision(this.ball, shape);
              break;
          }

          if (collision) {
            normal = this.physics.calculateBounceNormal(this.ball, shape);
            this.physics.handleBounce(this.ball, shape, normal);
            this.collisionCount++;
            
            // Уменьшаем здоровье фигуры
            shape.health--;
            
            // Если здоровье закончилось, деактивируем фигуру
            if (shape.health <= 0) {
              shape.active = false;
              this.score += shape.score;
            }
            
            collisionOccurred = true;
            break; // Обрабатываем только одно столкновение за кадр
          }
        }
        
        // Обновление UI
        this.updateUI();
        
        // Проверка завершения уровня
        const activeShapes = this.shapes.filter(shape => shape.active);
        if (activeShapes.length === 0) {
          this.showGameOver();
        }
      }
      
      updateUI() {
        document.getElementById('collisionCount').textContent = this.collisionCount;
        document.getElementById('score').textContent = this.score;
        
        const activeShapes = this.shapes.filter(shape => shape.active);
        document.getElementById('remainingShapes').textContent = activeShapes.length;
      }
      
      showGameOver() {
        const gameOver = document.getElementById('gameOver');
        const destroyedCount = this.shapes.length - this.shapes.filter(shape => shape.active).length;
        
        document.getElementById('destroyedCount').textContent = destroyedCount;
        document.getElementById('finalScore').textContent = this.score;
        
        gameOver.style.display = 'block';
        this.isPaused = true;
        document.getElementById('pauseBtn').textContent = 'Продолжить';
        document.getElementById('pauseBtn').classList.add('paused');
      }
      
      draw() {
        // Очистка холста
        this.ctx.fillStyle = '#111';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        
        // Рисование фигур
        this.shapes.forEach(shape => {
          if (!shape.active) return;
          
          // Прозрачность в зависимости от здоровья
          const alpha = shape.health / shape.initialHealth;
          this.ctx.globalAlpha = alpha;
          
          this.ctx.fillStyle = shape.color;
          
          switch (shape.type) {
            case 'circle':
              this.ctx.beginPath();
              this.ctx.arc(shape.x, shape.y, shape.radius, 0, Math.PI * 2);
              this.ctx.fill();
              break;
              
            case 'ellipse':
              this.ctx.save();
              this.ctx.translate(shape.x, shape.y);
              this.ctx.rotate(shape.rotation || 0);
              this.ctx.beginPath();
              this.ctx.ellipse(0, 0, shape.radiusX, shape.radiusY, 0, 0, Math.PI * 2);
              this.ctx.fill();
              this.ctx.restore();
              break;
              
            case 'polygon':
              this.ctx.beginPath();
              this.ctx.moveTo(shape.points[0].x, shape.points[0].y);
              for (let i = 1; i < shape.points.length; i++) {
                this.ctx.lineTo(shape.points[i].x, shape.points[i].y);
              }
              this.ctx.closePath();
              this.ctx.fill();
              break;
              
            case 'arc':
              this.ctx.save();
              this.ctx.translate(shape.x, shape.y);
              this.ctx.rotate(shape.rotation || 0);
              this.ctx.beginPath();
              this.ctx.ellipse(0, 0, shape.radiusX, shape.radiusY, 0, shape.startAngle, shape.endAngle);
              this.ctx.fill();
              this.ctx.restore();
              break;
          }
          
          this.ctx.globalAlpha = 1;
        });
        
        // Рисование шарика
        this.ctx.fillStyle = '#ff4444';
        this.ctx.beginPath();
        this.ctx.arc(this.ball.x, this.ball.y, this.ball.radius, 0, Math.PI * 2);
        this.ctx.fill();
        
        // Рисование границ
        this.ctx.strokeStyle = '#444';
        this.ctx.lineWidth = 2;
        this.ctx.strokeRect(0, 0, this.canvas.width, this.canvas.height);
      }
      
      animate(timestamp) {
        const deltaTime = timestamp - this.lastTime;
        this.lastTime = timestamp;
        
        this.update(deltaTime);
        this.draw();
        
        if (!this.isPaused) {
          requestAnimationFrame(this.animate.bind(this));
        }
      }
    }

    // Инициализация игры после загрузки DOM
    document.addEventListener('DOMContentLoaded', () => {
      const canvas = document.getElementById('gameCanvas');
      new Game(canvas);
    });
  </script>
</body>
</html>