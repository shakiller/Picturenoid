<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vector Editor</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, sans-serif;
            background: #1a1a2e;
            color: white;
            overflow: hidden;
            touch-action: none;
        }

        .app-container {
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        /* –í–µ—Ä—Ö–Ω—è—è –ø–∞–Ω–µ–ª—å */
        .top-bar {
            background: #16213e;
            padding: 8px;
            border-bottom: 2px solid #0f3460;
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
            min-height: 50px;
            align-items: center;
        }

        .btn {
            background: #e94560;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            min-width: 44px;
            min-height: 44px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .btn:active {
            background: #ff6b81;
        }

        .btn-secondary {
            background: #0f3460;
        }

        /* –û—Å–Ω–æ–≤–Ω–∞—è –æ–±–ª–∞—Å—Ç—å */
        .main-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            position: relative;
            overflow: hidden;
        }

        /* –ü–∞–Ω–µ–ª—å –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤ */
        .tools-panel {
            background: #16213e;
            padding: 8px;
            border-bottom: 1px solid #0f3460;
            display: flex;
            gap: 5px;
            overflow-x: auto;
            min-height: 50px;
        }

        .tool {
            background: #1a1a2e;
            border: 2px solid #e94560;
            border-radius: 8px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 20px;
            min-width: 44px;
            min-height: 44px;
            flex-shrink: 0;
        }

        .tool.active {
            background: #e94560;
        }

        /* –û–±–ª–∞—Å—Ç—å —Ä–∏—Å–æ–≤–∞–Ω–∏—è */
        .canvas-container {
            flex: 1;
            position: relative;
            background: #2d2d44;
            overflow: hidden;
            touch-action: none;
            background-image: 
                linear-gradient(#333 1px, transparent 1px),
                linear-gradient(90deg, #333 1px, transparent 1px);
            background-size: 20px 20px;
        }

        #drawingCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            cursor: crosshair;
        }

        #referenceImage {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
            opacity: 0.5;
        }

        /* –ù–∏–∂–Ω—è—è –ø–∞–Ω–µ–ª—å */
        .bottom-panel {
            background: #16213e;
            padding: 8px;
            border-top: 1px solid #0f3460;
            display: flex;
            gap: 10px;
            overflow-x: auto;
            min-height: 50px;
            align-items: center;
        }

        .property-group {
            display: flex;
            align-items: center;
            gap: 5px;
            flex-shrink: 0;
        }

        .property-label {
            font-size: 12px;
            color: #e94560;
            white-space: nowrap;
        }

        .color-palette {
            display: flex;
            gap: 3px;
        }

        .color {
            width: 24px;
            height: 24px;
            border: 2px solid transparent;
            border-radius: 4px;
            cursor: pointer;
        }

        .color.active {
            border-color: white;
        }

        .slider {
            width: 60px;
            height: 4px;
            -webkit-appearance: none;
            background: #0f3460;
            border-radius: 2px;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #e94560;
        }

        select {
            padding: 6px;
            border-radius: 4px;
            border: 1px solid #e94560;
            background: #1a1a2e;
            color: white;
            font-size: 12px;
        }

        /* –¢–æ—á–∫–∏ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è */
        .control-point {
            position: absolute;
            width: 20px;
            height: 20px;
            background: #00ffff;
            border: 3px solid #006666;
            border-radius: 50%;
            cursor: move;
            z-index: 1000;
            transform: translate(-50%, -50%);
            touch-action: none;
            box-shadow: 0 0 8px rgba(0, 255, 255, 0.8);
            transition: all 0.2s ease;
        }

        .control-point:hover {
            transform: translate(-50%, -50%) scale(1.2);
            box-shadow: 0 0 12px rgba(0, 255, 255, 1);
        }

        .control-point.active {
            background: #ffff00;
            border-color: #ff6600;
            box-shadow: 0 0 15px rgba(255, 255, 0, 1);
        }

        .control-handle {
            position: absolute;
            width: 16px;
            height: 16px;
            background: #ff00ff;
            border: 3px solid #660066;
            border-radius: 50%;
            cursor: pointer;
            z-index: 900;
            transform: translate(-50%, -50%);
            touch-action: none;
            box-shadow: 0 0 6px rgba(255, 0, 255, 0.8);
        }

        .control-handle:hover {
            transform: translate(-50%, -50%) scale(1.2);
            box-shadow: 0 0 10px rgba(255, 0, 255, 1);
        }

        /* –õ–∏–Ω–∏–∏ –¥–ª—è –∫–æ–Ω—Ç—Ä–æ–ª—å–Ω—ã—Ö —Ç–æ—á–µ–∫ –ë–µ–∑—å–µ */
        .control-line {
            position: absolute;
            height: 2px;
            background: rgba(255, 0, 255, 0.6);
            transform-origin: 0 0;
            pointer-events: none;
            z-index: 800;
        }

        /* –ü–æ–¥—Å–≤–µ—Ç–∫–∞ –≤—ã–±—Ä–∞–Ω–Ω–æ–π —Ç–æ—á–∫–∏ */
        .point-label {
            position: absolute;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            white-space: nowrap;
            z-index: 1100;
            pointer-events: none;
            transform: translate(10px, -50%);
        }

        /* –°–µ—Ç–∫–∞ –ø—Ä–∏–≤—è–∑–∫–∏ */
        .snap-guide {
            position: absolute;
            background: rgba(0, 255, 255, 0.3);
            pointer-events: none;
            z-index: 700;
        }

        .snap-guide.vertical {
            width: 1px;
            height: 100%;
        }

        .snap-guide.horizontal {
            width: 100%;
            height: 1px;
        }

        /* –ö–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã —Ç–æ—á–∫–∏ */
        .point-coordinates {
            position: absolute;
            background: rgba(0, 0, 0, 0.8);
            color: #00ffff;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-family: monospace;
            z-index: 1100;
            pointer-events: none;
            transform: translate(10px, 10px);
        }

        /* –ú–æ–¥–∞–ª—å–Ω—ã–µ –æ–∫–Ω–∞ */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.9);
            z-index: 10000;
            align-items: center;
            justify-content: center;
        }

        .modal-content {
            background: #16213e;
            padding: 20px;
            border-radius: 10px;
            width: 90%;
            max-width: 400px;
            border: 2px solid #e94560;
        }

        .modal-buttons {
            display: flex;
            gap: 8px;
            margin-top: 15px;
            flex-wrap: wrap;
        }

        .file-input {
            display: none;
        }

        /* –°—Ç–∞—Ç—É—Å –±–∞—Ä */
        .status-bar {
            background: #0f3460;
            padding: 5px 10px;
            font-size: 11px;
            display: flex;
            justify-content: space-between;
            min-height: 30px;
            align-items: center;
            flex-wrap: wrap;
        }

        /* –ó—É–º –∫–æ–Ω—Ç—Ä–æ–ª—ã */
        .zoom-controls {
            position: absolute;
            bottom: 60px;
            right: 10px;
            display: flex;
            flex-direction: column;
            gap: 5px;
            z-index: 100;
        }

        .zoom-btn {
            width: 40px;
            height: 40px;
            background: #e94560;
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }
    </style>
</head>
<body>
    <div class="app-container">
        <!-- –í–µ—Ä—Ö–Ω—è—è –ø–∞–Ω–µ–ª—å -->
        <div class="top-bar">
            <button class="btn btn-secondary" id="loadImageBtn">üìÅ –ó–∞–≥—Ä—É–∑–∏—Ç—å</button>
            <button class="btn" id="saveBtn">üíæ –°–æ—Ö—Ä–∞–Ω–∏—Ç—å</button>
            <button class="btn btn-secondary" id="newBtn">üÜï –ù–æ–≤—ã–π</button>
            <button class="btn btn-secondary" id="copyBtn">üìã –ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å</button>
            <button class="btn btn-secondary" id="pasteBtn">üìÑ –í—Å—Ç–∞–≤–∏—Ç—å</button>
            <button class="btn btn-secondary" id="deleteBtn">üóëÔ∏è –£–¥–∞–ª–∏—Ç—å</button>
        </div>

        <!-- –û—Å–Ω–æ–≤–Ω–∞—è –æ–±–ª–∞—Å—Ç—å -->
        <div class="main-area">
            <!-- –ü–∞–Ω–µ–ª—å –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤ -->
            <div class="tools-panel">
                <div class="tool active" data-tool="select" title="–í—ã–¥–µ–ª–µ–Ω–∏–µ">‚Üñ</div>
                <div class="tool" data-tool="move" title="–ü–µ—Ä–µ–º–µ—â–µ–Ω–∏–µ">‚ú•</div>
                <div class="tool" data-tool="pen" title="–ü–µ—Ä–æ">‚úèÔ∏è</div>
                <div class="tool" data-tool="line" title="–õ–∏–Ω–∏—è">üìè</div>
                <div class="tool" data-tool="rectangle" title="–ü—Ä—è–º–æ—É–≥–æ–ª—å–Ω–∏–∫">‚ñ°</div>
                <div class="tool" data-tool="circle" title="–ö—Ä—É–≥">‚óã</div>
                <div class="tool" data-tool="bezier" title="–ö—Ä–∏–≤–∞—è –ë–µ–∑—å–µ">‚éå</div>
                <div class="tool" data-tool="add-point" title="–î–æ–±–∞–≤–∏—Ç—å —Ç–æ—á–∫—É">‚äï</div>
                <div class="tool" data-tool="delete-point" title="–£–¥–∞–ª–∏—Ç—å —Ç–æ—á–∫—É">‚äñ</div>
            </div>

            <!-- –û–±–ª–∞—Å—Ç—å —Ä–∏—Å–æ–≤–∞–Ω–∏—è -->
            <div class="canvas-container" id="canvasContainer">
                <canvas id="drawingCanvas"></canvas>
                
                <!-- –ö–æ–Ω—Ç—Ä–æ–ª—ã –∑—É–º–∞ -->
                <div class="zoom-controls">
                    <button class="zoom-btn" id="zoomInBtn">+</button>
                    <button class="zoom-btn" id="zoomOutBtn">-</button>
                    <button class="zoom-btn" id="resetZoomBtn">100%</button>
                </div>
            </div>

            <!-- –ù–∏–∂–Ω—è—è –ø–∞–Ω–µ–ª—å -->
            <div class="bottom-panel">
                <div class="property-group">
                    <div class="property-label">–¶–≤–µ—Ç:</div>
                    <div class="color-palette">
                        <div class="color active" style="background: #ff0000;" data-color="#ff0000"></div>
                        <div class="color" style="background: #00ff00;" data-color="#00ff00"></div>
                        <div class="color" style="background: #0000ff;" data-color="#0000ff"></div>
                        <div class="color" style="background: #ffff00;" data-color="#ffff00"></div>
                        <div class="color" style="background: #ff00ff;" data-color="#ff00ff"></div>
                    </div>
                </div>

                <div class="property-group">
                    <div class="property-label">–¢–æ–ª—â–∏–Ω–∞:</div>
                    <input type="range" class="slider" id="strokeWidth" min="1" max="10" value="2">
                    <span id="widthValue" style="font-size: 11px;">2</span>
                </div>

                <div class="property-group">
                    <div class="property-label">–ü—Ä–∏–≤—è–∑–∫–∞:</div>
                    <select id="snapMode">
                        <option value="grid">–ö —Å–µ—Ç–∫–µ</option>
                        <option value="points">–ö —Ç–æ—á–∫–∞–º</option>
                        <option value="none">–ù–µ—Ç</option>
                    </select>
                </div>

                <div class="property-group">
                    <div class="property-label">–ü—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç—å:</div>
                    <input type="range" class="slider" id="imageOpacity" min="0" max="100" value="50">
                    <span id="opacityValue" style="font-size: 11px;">50%</span>
                </div>

                <div class="property-group">
                    <button class="btn" style="padding: 6px; font-size: 11px;" id="clearAllBtn">–û—á–∏—Å—Ç–∏—Ç—å –≤—Å—ë</button>
                </div>
            </div>
        </div>

        <!-- –°—Ç–∞—Ç—É—Å –±–∞—Ä -->
        <div class="status-bar">
            <span id="cursorPos">X:0 Y:0</span>
            <span id="toolInfo">–ò–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç: –í—ã–¥–µ–ª–µ–Ω–∏–µ</span>
            <span id="selectionInfo">–ù–µ –≤—ã–¥–µ–ª–µ–Ω–æ</span>
            <span id="zoomInfo">–ú–∞—Å—à—Ç–∞–±: 100%</span>
        </div>
    </div>

    <!-- –ú–æ–¥–∞–ª—å–Ω—ã–µ –æ–∫–Ω–∞ -->
    <div class="modal" id="loadImageModal">
        <div class="modal-content">
            <div style="text-align: center; margin-bottom: 15px; color: #e94560; font-size: 16px;">–ó–∞–≥—Ä—É–∑–∏—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ</div>
            <input type="file" id="imageInput" class="file-input" accept="image/*">
            <div class="modal-buttons">
                <button class="btn btn-secondary" onclick="document.getElementById('imageInput').click()">
                    –í—ã–±—Ä–∞—Ç—å —Ñ–∞–π–ª
                </button>
                <button class="btn" id="confirmLoadBtn">
                    –ó–∞–≥—Ä—É–∑–∏—Ç—å
                </button>
                <button class="btn btn-secondary" id="cancelLoadBtn">
                    –û—Ç–º–µ–Ω–∞
                </button>
            </div>
        </div>
    </div>

    <script>
        class VectorEditor {
            constructor() {
                this.canvas = document.getElementById('drawingCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.container = document.getElementById('canvasContainer');
                
                // –†–µ—Ñ–µ—Ä–µ–Ω—Å–Ω–∞—è –∫–∞—Ä—Ç–∏–Ω–∫–∞
                this.referenceImage = new Image();
                this.referenceImage.style.position = 'absolute';
                this.referenceImage.style.top = '0';
                this.referenceImage.style.left = '0';
                this.referenceImage.style.pointerEvents = 'none';
                this.referenceImage.style.opacity = '0.5';
                this.referenceImage.style.display = 'none';
                this.container.appendChild(this.referenceImage);
                
                // –°–æ—Å—Ç–æ—è–Ω–∏–µ —Ä–µ–¥–∞–∫—Ç–æ—Ä–∞
                this.currentTool = 'select';
                this.currentColor = '#ff0000';
                this.strokeWidth = 2;
                this.imageOpacity = 0.5;
                this.snapMode = 'grid';
                this.snapDistance = 10;
                
                // –¢—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏–∏
                this.scale = 1;
                this.offsetX = 0;
                this.offsetY = 0;
                this.isPanning = false;
                this.lastPanPoint = {x: 0, y: 0};
                
                // –î–∞–Ω–Ω—ã–µ
                this.shapes = [];
                this.currentShape = null;
                this.selectedShape = null;
                this.clipboard = null;
                this.controlPoints = [];
                this.controlLines = [];
                this.pointLabels = [];
                this.snapGuides = [];
                this.coordinateDisplay = null;
                
                // –í—Ä–µ–º–µ–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
                this.isDrawing = false;
                this.startPos = {x: 0, y: 0};
                this.lastPos = {x: 0, y: 0};
                this.selectedPoint = null;
                this.hoveredPoint = null;
                this.isMovingPoint = false;
                
                this.init();
            }
            
            init() {
                this.setupCanvas();
                this.setupEventListeners();
                this.setupModals();
                this.render();
            }
            
            setupCanvas() {
                this.resizeCanvas();
                window.addEventListener('resize', () => this.resizeCanvas());
            }
            
            resizeCanvas() {
                const rect = this.container.getBoundingClientRect();
                this.canvas.width = rect.width;
                this.canvas.height = rect.height;
                this.updateReferenceImagePosition();
                this.render();
            }
            
            setupEventListeners() {
                // –ò–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã
                document.querySelectorAll('.tool').forEach(tool => {
                    tool.addEventListener('click', (e) => {
                        document.querySelectorAll('.tool').forEach(t => t.classList.remove('active'));
                        e.currentTarget.classList.add('active');
                        this.currentTool = e.currentTarget.dataset.tool;
                        this.clearControlPoints();
                        if (this.selectedShape) {
                            this.createControlPoints(this.selectedShape);
                        }
                        this.updateToolInfo();
                    });
                });
                
                // –¶–≤–µ—Ç–∞
                document.querySelectorAll('.color').forEach(color => {
                    color.addEventListener('click', (e) => {
                        document.querySelectorAll('.color').forEach(c => c.classList.remove('active'));
                        e.currentTarget.classList.add('active');
                        this.currentColor = e.currentTarget.dataset.color;
                    });
                });
                
                // –°–ª–∞–π–¥–µ—Ä—ã
                document.getElementById('strokeWidth').addEventListener('input', (e) => {
                    this.strokeWidth = parseInt(e.target.value);
                    document.getElementById('widthValue').textContent = this.strokeWidth;
                });
                
                document.getElementById('imageOpacity').addEventListener('input', (e) => {
                    this.imageOpacity = parseInt(e.target.value) / 100;
                    document.getElementById('opacityValue').textContent = e.target.value + '%';
                    this.referenceImage.style.opacity = this.imageOpacity;
                });
                
                document.getElementById('snapMode').addEventListener('change', (e) => {
                    this.snapMode = e.target.value;
                });
                
                // –ö–Ω–æ–ø–∫–∏
                document.getElementById('newBtn').addEventListener('click', () => this.newProject());
                document.getElementById('copyBtn').addEventListener('click', () => this.copyShape());
                document.getElementById('pasteBtn').addEventListener('click', () => this.pasteShape());
                document.getElementById('deleteBtn').addEventListener('click', () => this.deleteShape());
                document.getElementById('clearAllBtn').addEventListener('click', () => this.clearAll());
                
                // –ó—É–º
                document.getElementById('zoomInBtn').addEventListener('click', () => this.zoom(1.2));
                document.getElementById('zoomOutBtn').addEventListener('click', () => this.zoom(0.8));
                document.getElementById('resetZoomBtn').addEventListener('click', () => this.resetZoom());
                
                // –°–æ–±—ã—Ç–∏—è –º—ã—à–∏ –∏ –∫–∞—Å–∞–Ω–∏—è –¥–ª—è canvas
                this.canvas.addEventListener('mousedown', (e) => this.onPointerStart(e));
                this.canvas.addEventListener('mousemove', (e) => this.onPointerMove(e));
                this.canvas.addEventListener('mouseup', (e) => this.onPointerEnd(e));
                
                this.canvas.addEventListener('touchstart', (e) => this.onPointerStart(e));
                this.canvas.addEventListener('touchmove', (e) => this.onPointerMove(e));
                this.canvas.addEventListener('touchend', (e) => this.onPointerEnd(e));
                
                // –ö–æ–ª–µ—Å–æ –º—ã—à–∏ –¥–ª—è –∑—É–º–∞
                this.canvas.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    const delta = e.deltaY > 0 ? 0.8 : 1.2;
                    const rect = this.canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    this.zoom(delta, x, y);
                });
                
                // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø–æ–∑–∏—Ü–∏–∏ –∫—É—Ä—Å–æ—Ä–∞
                this.canvas.addEventListener('mousemove', (e) => this.updateCursorPos(e));
                this.canvas.addEventListener('touchmove', (e) => this.updateCursorPos(e));
            }
            
            setupModals() {
                document.getElementById('loadImageBtn').addEventListener('click', () => {
                    this.showModal('loadImageModal');
                });
                
                document.getElementById('saveBtn').addEventListener('click', () => {
                    this.saveProject();
                });
                
                document.getElementById('imageInput').addEventListener('change', (e) => this.handleImageSelect(e));
                document.getElementById('confirmLoadBtn').addEventListener('click', () => this.loadSelectedImage());
                document.getElementById('cancelLoadBtn').addEventListener('click', () => this.hideModal('loadImageModal'));
            }
            
            getWorldPos(canvasPos) {
                return {
                    x: (canvasPos.x - this.offsetX) / this.scale,
                    y: (canvasPos.y - this.offsetY) / this.scale
                };
            }
            
            getCanvasPos(worldPos) {
                return {
                    x: worldPos.x * this.scale + this.offsetX,
                    y: worldPos.y * this.scale + this.offsetY
                };
            }
            
            getPointerPos(e) {
                const rect = this.canvas.getBoundingClientRect();
                let clientX, clientY;
                
                if (e.touches) {
                    clientX = e.touches[0].clientX;
                    clientY = e.touches[0].clientY;
                } else {
                    clientX = e.clientX;
                    clientY = e.clientY;
                }
                
                return {
                    x: clientX - rect.left,
                    y: clientY - rect.top
                };
            }
            
            snapToGrid(worldPos) {
                if (this.snapMode === 'none') return worldPos;
                
                const gridSize = 10;
                let snappedX = Math.round(worldPos.x / gridSize) * gridSize;
                let snappedY = Math.round(worldPos.y / gridSize) * gridSize;
                
                // –ü—Ä–∏–≤—è–∑–∫–∞ –∫ –¥—Ä—É–≥–∏–º —Ç–æ—á–∫–∞–º
                if (this.snapMode === 'points' && this.selectedShape) {
                    const otherPoints = this.getAllPointsExceptCurrent();
                    for (let point of otherPoints) {
                        const dx = Math.abs(point.x - worldPos.x);
                        const dy = Math.abs(point.y - worldPos.y);
                        
                        if (dx < this.snapDistance && dy < this.snapDistance) {
                            snappedX = point.x;
                            snappedY = point.y;
                            this.showSnapGuides(point);
                            break;
                        }
                    }
                }
                
                return { x: snappedX, y: snappedY };
            }
            
            getAllPointsExceptCurrent() {
                const points = [];
                
                // –í—Å–µ —Ç–æ—á–∫–∏ –≤—Å–µ—Ö —Ñ–∏–≥—É—Ä
                this.shapes.forEach(shape => {
                    if (shape !== this.selectedShape) {
                        if (shape.points) {
                            points.push(...shape.points);
                        }
                        if (shape.controlPoints) {
                            points.push(...shape.controlPoints);
                        }
                    }
                });
                
                // –¢–æ—á–∫–∏ —Ç–µ–∫—É—â–µ–π —Ñ–∏–≥—É—Ä—ã, –∫—Ä–æ–º–µ –≤—ã–±—Ä–∞–Ω–Ω–æ–π
                if (this.selectedShape) {
                    if (this.selectedShape.points) {
                        this.selectedShape.points.forEach((point, index) => {
                            if (!this.selectedPoint || this.selectedPoint.type !== 'vertex' || this.selectedPoint.index !== index) {
                                points.push(point);
                            }
                        });
                    }
                    if (this.selectedShape.controlPoints) {
                        this.selectedShape.controlPoints.forEach((point, index) => {
                            if (!this.selectedPoint || this.selectedPoint.type !== 'handle' || this.selectedPoint.index !== index) {
                                points.push(point);
                            }
                        });
                    }
                }
                
                return points;
            }
            
            showSnapGuides(snapPoint) {
                this.clearSnapGuides();
                
                const canvasPos = this.getCanvasPos(snapPoint);
                
                // –í–µ—Ä—Ç–∏–∫–∞–ª—å–Ω–∞—è –Ω–∞–ø—Ä–∞–≤–ª—è—é—â–∞—è
                const vGuide = document.createElement('div');
                vGuide.className = 'snap-guide vertical';
                vGuide.style.left = canvasPos.x + 'px';
                vGuide.style.top = '0';
                this.container.appendChild(vGuide);
                this.snapGuides.push(vGuide);
                
                // –ì–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω–∞—è –Ω–∞–ø—Ä–∞–≤–ª—è—é—â–∞—è
                const hGuide = document.createElement('div');
                hGuide.className = 'snap-guide horizontal';
                hGuide.style.left = '0';
                hGuide.style.top = canvasPos.y + 'px';
                this.container.appendChild(hGuide);
                this.snapGuides.push(hGuide);
            }
            
            clearSnapGuides() {
                this.snapGuides.forEach(guide => guide.remove());
                this.snapGuides = [];
            }
            
            onPointerStart(e) {
                e.preventDefault();
                const canvasPos = this.getPointerPos(e);
                const worldPos = this.getWorldPos(canvasPos);
                
                this.startPos = {...worldPos};
                this.lastPos = {...worldPos};
                this.lastPanPoint = {...canvasPos};
                
                // –ü–∞–Ω–Ω–∏–Ω–≥ –ø—Ä–∏ –∑–∞–∂–∞—Ç–æ–π –ø—Ä–∞–≤–æ–π –∫–Ω–æ–ø–∫–µ –∏–ª–∏ –¥–≤—É—Ö –ø–∞–ª—å—Ü–∞—Ö
                if (e.button === 2 || e.touches?.length >= 2) {
                    this.isPanning = true;
                    return;
                }
                
                // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ç–æ—á–∫–∏ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è
                const controlPoint = this.getControlPointAt(canvasPos);
                if (controlPoint) {
                    this.selectedPoint = controlPoint;
                    this.setActivePoint(controlPoint.element);
                    this.isMovingPoint = true;
                    this.isDrawing = true;
                    return;
                }
                
                // –ü—Ä–æ–≤–µ—Ä—è–µ–º –≤—ã–¥–µ–ª–µ–Ω–∏–µ —Ñ–∏–≥—É—Ä—ã
                const shape = this.getShapeAt(worldPos);
                if (this.currentTool === 'select' || this.currentTool === 'move') {
                    this.selectedShape = shape;
                    this.clearControlPoints();
                    if (this.selectedShape) {
                        this.createControlPoints(this.selectedShape);
                    }
                    this.updateSelectionInfo();
                    this.render();
                    
                    if (this.selectedShape && this.currentTool === 'move') {
                        this.isDrawing = true;
                    }
                    return;
                }
                
                // –£–¥–∞–ª–µ–Ω–∏–µ —Ç–æ—á–∫–∏
                if (this.currentTool === 'delete-point' && this.selectedShape) {
                    this.deletePointAt(worldPos);
                    return;
                }
                
                // –î–æ–±–∞–≤–ª–µ–Ω–∏–µ —Ç–æ—á–∫–∏
                if (this.currentTool === 'add-point' && this.selectedShape) {
                    this.addPointAt(worldPos);
                    return;
                }
                
                // –ù–∞—á–∏–Ω–∞–µ–º —Ä–∏—Å–æ–≤–∞–Ω–∏–µ –Ω–æ–≤–æ–π —Ñ–∏–≥—É—Ä—ã
                this.startNewShape(worldPos);
            }
            
            onPointerMove(e) {
                e.preventDefault();
                const canvasPos = this.getPointerPos(e);
                const worldPos = this.getWorldPos(canvasPos);
                const snappedPos = this.snapToGrid(worldPos);
                
                // –û–±–Ω–æ–≤–ª—è–µ–º —Ö–æ–≤–µ—Ä —Ç–æ—á–∫–∏
                this.updateHoveredPoint(canvasPos);
                
                if (this.isPanning) {
                    this.pan(canvasPos);
                } else if (this.isMovingPoint && this.selectedPoint) {
                    this.moveControlPoint(snappedPos);
                    this.updateCoordinateDisplay(snappedPos);
                } else if (this.currentTool === 'move' && this.selectedShape && this.isDrawing) {
                    this.moveShape(worldPos);
                } else if (this.isDrawing && this.currentShape) {
                    this.updateCurrentShape(snappedPos);
                }
                
                this.lastPos = {...worldPos};
                this.lastPanPoint = {...canvasPos};
                this.render();
            }
            
            onPointerEnd(e) {
                if (this.isDrawing && this.currentShape) {
                    this.finalizeShape();
                }
                this.selectedPoint = null;
                this.isMovingPoint = false;
                this.clearActivePoint();
                this.clearSnapGuides();
                this.clearCoordinateDisplay();
                this.isDrawing = false;
                this.isPanning = false;
            }
            
            updateHoveredPoint(canvasPos) {
                const controlPoint = this.getControlPointAt(canvasPos);
                
                // –£–±–∏—Ä–∞–µ–º —Ö–æ–≤–µ—Ä —Å–æ –≤—Å–µ—Ö —Ç–æ—á–µ–∫
                this.controlPoints.forEach(point => {
                    point.classList.remove('hover');
                });
                
                // –î–æ–±–∞–≤–ª—è–µ–º —Ö–æ–≤–µ—Ä –Ω–∞ –Ω–∞–π–¥–µ–Ω–Ω—É—é —Ç–æ—á–∫—É
                if (controlPoint) {
                    controlPoint.element.classList.add('hover');
                }
            }
            
            setActivePoint(element) {
                this.clearActivePoint();
                element.classList.add('active');
                
                // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –ø–æ–¥–ø–∏—Å—å –¥–ª—è —Ç–æ—á–∫–∏
                const index = parseInt(element.dataset.index);
                const type = element.dataset.type;
                const canvasPos = {
                    x: parseFloat(element.style.left),
                    y: parseFloat(element.style.top)
                };
                
                const label = document.createElement('div');
                label.className = 'point-label';
                label.textContent = `${type === 'vertex' ? '–¢–æ—á–∫–∞' : '–ö–æ–Ω—Ç—Ä–æ–ª—å–Ω–∞—è'} ${index + 1}`;
                label.style.left = canvasPos.x + 'px';
                label.style.top = canvasPos.y + 'px';
                
                this.container.appendChild(label);
                this.pointLabels.push(label);
                
                // –°–æ–∑–¥–∞–µ–º –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç
                this.createCoordinateDisplay(canvasPos);
            }
            
            createCoordinateDisplay(canvasPos) {
                this.clearCoordinateDisplay();
                
                this.coordinateDisplay = document.createElement('div');
                this.coordinateDisplay.className = 'point-coordinates';
                this.coordinateDisplay.style.left = canvasPos.x + 'px';
                this.coordinateDisplay.style.top = canvasPos.y + 'px';
                this.container.appendChild(this.coordinateDisplay);
            }
            
            updateCoordinateDisplay(worldPos) {
                if (this.coordinateDisplay) {
                    this.coordinateDisplay.textContent = `X:${Math.round(worldPos.x)} Y:${Math.round(worldPos.y)}`;
                    const canvasPos = this.getCanvasPos(worldPos);
                    this.coordinateDisplay.style.left = canvasPos.x + 'px';
                    this.coordinateDisplay.style.top = canvasPos.y + 'px';
                }
            }
            
            clearCoordinateDisplay() {
                if (this.coordinateDisplay) {
                    this.coordinateDisplay.remove();
                    this.coordinateDisplay = null;
                }
            }
            
            clearActivePoint() {
                this.controlPoints.forEach(point => {
                    point.classList.remove('active');
                });
                this.pointLabels.forEach(label => label.remove());
                this.pointLabels = [];
            }
            
            pan(currentPos) {
                const deltaX = currentPos.x - this.lastPanPoint.x;
                const deltaY = currentPos.y - this.lastPanPoint.y;
                
                this.offsetX += deltaX;
                this.offsetY += deltaY;
                
                this.updateControlPointsPosition();
                this.updateReferenceImagePosition();
            }
            
            zoom(factor, centerX = null, centerY = null) {
                const oldScale = this.scale;
                this.scale *= factor;
                this.scale = Math.max(0.1, Math.min(5, this.scale));
                
                if (centerX !== null && centerY !== null) {
                    const worldX = (centerX - this.offsetX) / oldScale;
                    const worldY = (centerY - this.offsetY) / oldScale;
                    
                    this.offsetX = centerX - worldX * this.scale;
                    this.offsetY = centerY - worldY * this.scale;
                }
                
                this.updateControlPointsPosition();
                this.updateReferenceImagePosition();
                this.updateZoomInfo();
                this.render();
            }
            
            resetZoom() {
                this.scale = 1;
                this.offsetX = 0;
                this.offsetY = 0;
                this.updateControlPointsPosition();
                this.updateReferenceImagePosition();
                this.updateZoomInfo();
                this.render();
            }
            
            updateReferenceImagePosition() {
                if (this.referenceImage.style.display !== 'none') {
                    this.referenceImage.style.transform = `translate(${this.offsetX}px, ${this.offsetY}px) scale(${this.scale})`;
                    this.referenceImage.style.transformOrigin = '0 0';
                }
            }
            
            updateControlPointsPosition() {
                this.controlPoints.forEach(point => {
                    if (this.selectedShape) {
                        const pointData = this.getPointFromShape(this.selectedShape, 
                            parseInt(point.dataset.index), point.dataset.type);
                        if (pointData) {
                            const canvasPos = this.getCanvasPos(pointData);
                            point.style.left = canvasPos.x + 'px';
                            point.style.top = canvasPos.y + 'px';
                        }
                    }
                });
                
                // –û–±–Ω–æ–≤–ª—è–µ–º –ª–∏–Ω–∏–∏ –∫–æ–Ω—Ç—Ä–æ–ª—è
                this.updateControlLines();
                
                // –û–±–Ω–æ–≤–ª—è–µ–º –ø–æ–¥–ø–∏—Å–∏
                this.pointLabels.forEach(label => {
                    const point = this.controlPoints.find(p => 
                        p.classList.contains('active') && 
                        p.style.left === label.style.left && 
                        p.style.top === label.style.top
                    );
                    if (point) {
                        label.style.left = point.style.left;
                        label.style.top = point.style.top;
                    }
                });
            }
            
            // –°–æ–∑–¥–∞–Ω–∏–µ —Ñ–∏–≥—É—Ä
            startNewShape(worldPos) {
                const snappedPos = this.snapToGrid(worldPos);
                
                this.currentShape = {
                    type: this.currentTool,
                    points: [{x: snappedPos.x, y: snappedPos.y}],
                    color: this.currentColor,
                    strokeWidth: this.strokeWidth,
                    id: Date.now()
                };
                
                if (this.currentTool === 'rectangle' || this.currentTool === 'circle') {
                    this.currentShape.x = snappedPos.x;
                    this.currentShape.y = snappedPos.y;
                    this.currentShape.width = 0;
                    this.currentShape.height = 0;
                }
                
                this.isDrawing = true;
            }
            
            updateCurrentShape(worldPos) {
                if (!this.currentShape) return;
                
                switch (this.currentShape.type) {
                    case 'pen':
                        this.currentShape.points.push({x: worldPos.x, y: worldPos.y});
                        break;
                    case 'line':
                        if (this.currentShape.points.length === 1) {
                            this.currentShape.points.push({x: worldPos.x, y: worldPos.y});
                        } else {
                            this.currentShape.points[1] = {x: worldPos.x, y: worldPos.y};
                        }
                        break;
                    case 'rectangle':
                        this.currentShape.width = worldPos.x - this.currentShape.x;
                        this.currentShape.height = worldPos.y - this.currentShape.y;
                        break;
                    case 'circle':
                        const radius = Math.sqrt(
                            Math.pow(worldPos.x - this.currentShape.x, 2) + 
                            Math.pow(worldPos.y - this.currentShape.y, 2)
                        );
                        this.currentShape.radius = radius;
                        break;
                    case 'bezier':
                        if (this.currentShape.points.length === 1) {
                            this.currentShape.points.push({x: worldPos.x, y: worldPos.y});
                            // –î–æ–±–∞–≤–ª—è–µ–º –∫–æ–Ω—Ç—Ä–æ–ª—å–Ω—ã–µ —Ç–æ—á–∫–∏
                            this.currentShape.controlPoints = [
                                {x: (this.currentShape.points[0].x + worldPos.x) / 2, y: this.currentShape.points[0].y},
                                {x: (this.currentShape.points[0].x + worldPos.x) / 2, y: worldPos.y}
                            ];
                        } else {
                            this.currentShape.points[1] = {x: worldPos.x, y: worldPos.y};
                        }
                        break;
                }
            }
            
            finalizeShape() {
                if (this.currentShape) {
                    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–π —Ä–∞–∑–º–µ—Ä
                    let shouldAdd = true;
                    
                    if (this.currentShape.type === 'rectangle') {
                        if (Math.abs(this.currentShape.width) < 5 || Math.abs(this.currentShape.height) < 5) {
                            shouldAdd = false;
                        }
                    } else if (this.currentShape.type === 'circle') {
                        if (this.currentShape.radius < 5) {
                            shouldAdd = false;
                        }
                    } else if (this.currentShape.points) {
                        if (this.currentShape.points.length < 2) {
                            shouldAdd = false;
                        }
                    }
                    
                    if (shouldAdd) {
                        this.shapes.push(this.currentShape);
                        this.selectedShape = this.currentShape;
                        this.createControlPoints(this.currentShape);
                        this.updateSelectionInfo();
                    }
                    
                    this.currentShape = null;
                }
            }
            
            // –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Ç–æ—á–∫–∞–º–∏
            createControlPoints(shape) {
                this.clearControlPoints();
                
                if (!shape) return;
                
                switch (shape.type) {
                    case 'rectangle':
                        this.createRectanglePoints(shape);
                        break;
                    case 'circle':
                        this.createCirclePoints(shape);
                        break;
                    case 'line':
                    case 'pen':
                    case 'bezier':
                        this.createPathPoints(shape);
                        break;
                }
                
                // –°–æ–∑–¥–∞–µ–º –ª–∏–Ω–∏–∏ –¥–ª—è –∫–æ–Ω—Ç—Ä–æ–ª—å–Ω—ã—Ö —Ç–æ—á–µ–∫
                this.createControlLines(shape);
            }
            
            createRectanglePoints(shape) {
                const points = [
                    {x: shape.x, y: shape.y, label: '–õ–µ–≤—ã–π –≤–µ—Ä—Ö–Ω–∏–π'},
                    {x: shape.x + shape.width, y: shape.y, label: '–ü—Ä–∞–≤—ã–π –≤–µ—Ä—Ö–Ω–∏–π'},
                    {x: shape.x + shape.width, y: shape.y + shape.height, label: '–ü—Ä–∞–≤—ã–π –Ω–∏–∂–Ω–∏–π'},
                    {x: shape.x, y: shape.y + shape.height, label: '–õ–µ–≤—ã–π –Ω–∏–∂–Ω–∏–π'}
                ];
                
                points.forEach((point, index) => {
                    this.createControlPoint(point, 'vertex', index, point.label);
                });
            }
            
            createCirclePoints(shape) {
                const points = [
                    {x: shape.x - shape.radius, y: shape.y, label: '–õ–µ–≤–∞—è'},
                    {x: shape.x + shape.radius, y: shape.y, label: '–ü—Ä–∞–≤–∞—è'},
                    {x: shape.x, y: shape.y - shape.radius, label: '–í–µ—Ä—Ö–Ω—è—è'},
                    {x: shape.x, y: shape.y + shape.radius, label: '–ù–∏–∂–Ω—è—è'}
                ];
                
                points.forEach((point, index) => {
                    this.createControlPoint(point, 'radius', index, point.label);
                });
            }
            
            createPathPoints(shape) {
                if (shape.points) {
                    shape.points.forEach((point, index) => {
                        this.createControlPoint(point, 'vertex', index, `–¢–æ—á–∫–∞ ${index + 1}`);
                    });
                }
                
                if (shape.controlPoints) {
                    shape.controlPoints.forEach((point, index) => {
                        this.createControlPoint(point, 'handle', index, `–ö–æ–Ω—Ç—Ä–æ–ª—å–Ω–∞—è ${index + 1}`);
                    });
                }
            }
            
            createControlPoint(worldPos, type, index, label = '') {
                const div = document.createElement('div');
                div.className = type === 'handle' ? 'control-handle' : 'control-point';
                const canvasPos = this.getCanvasPos(worldPos);
                div.style.left = canvasPos.x + 'px';
                div.style.top = canvasPos.y + 'px';
                div.dataset.type = type;
                div.dataset.index = index;
                div.dataset.label = label;
                div.title = label;
                
                // –î–æ–±–∞–≤–ª—è–µ–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ —Å–æ–±—ã—Ç–∏–π –¥–ª—è —Ç–æ—á–µ–∫
                div.addEventListener('mousedown', (e) => {
                    e.stopPropagation();
                    this.selectedPoint = {
                        element: div,
                        type: type,
                        index: index
                    };
                    this.setActivePoint(div);
                    this.isMovingPoint = true;
                    this.isDrawing = true;
                });
                
                div.addEventListener('touchstart', (e) => {
                    e.stopPropagation();
                    this.selectedPoint = {
                        element: div,
                        type: type,
                        index: index
                    };
                    this.setActivePoint(div);
                    this.isMovingPoint = true;
                    this.isDrawing = true;
                });
                
                this.container.appendChild(div);
                this.controlPoints.push(div);
            }
            
            createControlLines(shape) {
                if (shape.type === 'bezier' && shape.controlPoints && shape.points) {
                    // –õ–∏–Ω–∏—è –æ—Ç –ø–µ—Ä–≤–æ–π —Ç–æ—á–∫–∏ –∫ –ø–µ—Ä–≤–æ–π –∫–æ–Ω—Ç—Ä–æ–ª—å–Ω–æ–π —Ç–æ—á–∫–µ
                    if (shape.points[0] && shape.controlPoints[0]) {
                        this.createControlLine(shape.points[0], shape.controlPoints[0]);
                    }
                    
                    // –õ–∏–Ω–∏—è –æ—Ç –≤—Ç–æ—Ä–æ–π —Ç–æ—á–∫–∏ –∫–æ –≤—Ç–æ—Ä–æ–π –∫–æ–Ω—Ç—Ä–æ–ª—å–Ω–æ–π —Ç–æ—á–∫–µ
                    if (shape.points[1] && shape.controlPoints[1]) {
                        this.createControlLine(shape.points[1], shape.controlPoints[1]);
                    }
                }
            }
            
            createControlLine(startWorld, endWorld) {
                const startCanvas = this.getCanvasPos(startWorld);
                const endCanvas = this.getCanvasPos(endWorld);
                
                const line = document.createElement('div');
                line.className = 'control-line';
                
                const dx = endCanvas.x - startCanvas.x;
                const dy = endCanvas.y - startCanvas.y;
                const length = Math.sqrt(dx * dx + dy * dy);
                const angle = Math.atan2(dy, dx) * 180 / Math.PI;
                
                line.style.left = startCanvas.x + 'px';
                line.style.top = startCanvas.y + 'px';
                line.style.width = length + 'px';
                line.style.transform = `rotate(${angle}deg)`;
                
                this.container.appendChild(line);
                this.controlLines.push(line);
            }
            
            updateControlLines() {
                this.controlLines.forEach(line => line.remove());
                this.controlLines = [];
                
                if (this.selectedShape && this.selectedShape.type === 'bezier') {
                    this.createControlLines(this.selectedShape);
                }
            }
            
            clearControlPoints() {
                this.controlPoints.forEach(point => {
                    point.remove();
                });
                this.controlPoints = [];
                
                this.controlLines.forEach(line => {
                    line.remove();
                });
                this.controlLines = [];
                
                this.clearActivePoint();
                this.clearSnapGuides();
                this.clearCoordinateDisplay();
            }
            
            getControlPointAt(canvasPos) {
                for (let point of this.controlPoints) {
                    const rect = point.getBoundingClientRect();
                    const pointX = rect.left + rect.width / 2;
                    const pointY = rect.top + rect.height / 2;
                    
                    const distance = Math.sqrt(
                        Math.pow(canvasPos.x - pointX, 2) +
                        Math.pow(canvasPos.y - pointY, 2)
                    );
                    
                    if (distance < 30) {
                        return {
                            element: point,
                            type: point.dataset.type,
                            index: parseInt(point.dataset.index),
                            label: point.dataset.label
                        };
                    }
                }
                return null;
            }
            
            getPointFromShape(shape, index, type) {
                if (!shape) return null;
                
                try {
                    switch (shape.type) {
                        case 'rectangle':
                            const rectPoints = [
                                {x: shape.x, y: shape.y},
                                {x: shape.x + shape.width, y: shape.y},
                                {x: shape.x + shape.width, y: shape.y + shape.height},
                                {x: shape.x, y: shape.y + shape.height}
                            ];
                            return index < rectPoints.length ? rectPoints[index] : null;
                        case 'circle':
                            const circlePoints = [
                                {x: shape.x - shape.radius, y: shape.y},
                                {x: shape.x + shape.radius, y: shape.y},
                                {x: shape.x, y: shape.y - shape.radius},
                                {x: shape.x, y: shape.y + shape.radius}
                            ];
                            return index < circlePoints.length ? circlePoints[index] : null;
                        case 'line':
                        case 'pen':
                        case 'bezier':
                            if (type === 'vertex' && shape.points && index < shape.points.length) {
                                return shape.points[index];
                            } else if (type === 'handle' && shape.controlPoints && index < shape.controlPoints.length) {
                                return shape.controlPoints[index];
                            }
                            return null;
                    }
                } catch (error) {
                    console.error('Error getting point from shape:', error);
                    return null;
                }
                return null;
            }
            
            moveControlPoint(worldPos) {
                if (!this.selectedPoint || !this.selectedShape) return;
                
                try {
                    // –û–±–Ω–æ–≤–ª—è–µ–º –¥–∞–Ω–Ω—ã–µ —Ñ–∏–≥—É—Ä—ã
                    switch (this.selectedShape.type) {
                        case 'rectangle':
                            this.moveRectanglePoint(worldPos);
                            break;
                        case 'circle':
                            this.moveCirclePoint(worldPos);
                            break;
                        case 'line':
                        case 'pen':
                        case 'bezier':
                            this.movePathPoint(worldPos);
                            break;
                    }
                    
                    // –û–±–Ω–æ–≤–ª—è–µ–º –ø–æ–∑–∏—Ü–∏—é —ç–ª–µ–º–µ–Ω—Ç–∞
                    const canvasPos = this.getCanvasPos(worldPos);
                    this.selectedPoint.element.style.left = canvasPos.x + 'px';
                    this.selectedPoint.element.style.top = canvasPos.y + 'px';
                    
                    // –û–±–Ω–æ–≤–ª—è–µ–º –ø–æ–¥–ø–∏—Å—å
                    this.updatePointLabel();
                    
                    // –û–±–Ω–æ–≤–ª—è–µ–º –ª–∏–Ω–∏–∏ –∫–æ–Ω—Ç—Ä–æ–ª—è
                    this.updateControlLines();
                    
                } catch (error) {
                    console.error('Error moving control point:', error);
                }
            }
            
            updatePointLabel() {
                if (this.selectedPoint && this.pointLabels.length > 0) {
                    const label = this.pointLabels[0];
                    label.style.left = this.selectedPoint.element.style.left;
                    label.style.top = this.selectedPoint.element.style.top;
                }
            }
            
            moveRectanglePoint(worldPos) {
                switch (this.selectedPoint.index) {
                    case 0: // –ª–µ–≤—ã–π –≤–µ—Ä—Ö–Ω–∏–π
                        this.selectedShape.width += this.selectedShape.x - worldPos.x;
                        this.selectedShape.height += this.selectedShape.y - worldPos.y;
                        this.selectedShape.x = worldPos.x;
                        this.selectedShape.y = worldPos.y;
                        break;
                    case 1: // –ø—Ä–∞–≤—ã–π –≤–µ—Ä—Ö–Ω–∏–π
                        this.selectedShape.width = worldPos.x - this.selectedShape.x;
                        this.selectedShape.height += this.selectedShape.y - worldPos.y;
                        this.selectedShape.y = worldPos.y;
                        break;
                    case 2: // –ø—Ä–∞–≤—ã–π –Ω–∏–∂–Ω–∏–π
                        this.selectedShape.width = worldPos.x - this.selectedShape.x;
                        this.selectedShape.height = worldPos.y - this.selectedShape.y;
                        break;
                    case 3: // –ª–µ–≤—ã–π –Ω–∏–∂–Ω–∏–π
                        this.selectedShape.width += this.selectedShape.x - worldPos.x;
                        this.selectedShape.height = worldPos.y - this.selectedShape.y;
                        this.selectedShape.x = worldPos.x;
                        break;
                }
            }
            
            moveCirclePoint(worldPos) {
                switch (this.selectedPoint.index) {
                    case 0: // –ª–µ–≤–∞—è
                        this.selectedShape.radius = this.selectedShape.x - worldPos.x;
                        break;
                    case 1: // –ø—Ä–∞–≤–∞—è
                        this.selectedShape.radius = worldPos.x - this.selectedShape.x;
                        break;
                    case 2: // –≤–µ—Ä—Ö–Ω—è—è
                        this.selectedShape.radius = this.selectedShape.y - worldPos.y;
                        break;
                    case 3: // –Ω–∏–∂–Ω—è—è
                        this.selectedShape.radius = worldPos.y - this.selectedShape.y;
                        break;
                }
                this.selectedShape.radius = Math.abs(this.selectedShape.radius);
            }
            
            movePathPoint(worldPos) {
                if (this.selectedPoint.type === 'vertex') {
                    if (this.selectedShape.points && this.selectedPoint.index < this.selectedShape.points.length) {
                        this.selectedShape.points[this.selectedPoint.index] = {x: worldPos.x, y: worldPos.y};
                    }
                } else if (this.selectedPoint.type === 'handle') {
                    if (this.selectedShape.controlPoints && this.selectedPoint.index < this.selectedShape.controlPoints.length) {
                        this.selectedShape.controlPoints[this.selectedPoint.index] = {x: worldPos.x, y: worldPos.y};
                    }
                }
            }
            
            moveShape(worldPos) {
                if (!this.selectedShape) return;
                
                const deltaX = worldPos.x - this.lastPos.x;
                const deltaY = worldPos.y - this.lastPos.y;
                
                switch (this.selectedShape.type) {
                    case 'rectangle':
                        this.selectedShape.x += deltaX;
                        this.selectedShape.y += deltaY;
                        break;
                    case 'circle':
                        this.selectedShape.x += deltaX;
                        this.selectedShape.y += deltaY;
                        break;
                    case 'line':
                    case 'pen':
                    case 'bezier':
                        if (this.selectedShape.points) {
                            this.selectedShape.points.forEach(point => {
                                point.x += deltaX;
                                point.y += deltaY;
                            });
                        }
                        if (this.selectedShape.controlPoints) {
                            this.selectedShape.controlPoints.forEach(point => {
                                point.x += deltaX;
                                point.y += deltaY;
                            });
                        }
                        break;
                }
                
                // –û–±–Ω–æ–≤–ª—è–µ–º —Ç–æ—á–∫–∏ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è
                this.clearControlPoints();
                this.createControlPoints(this.selectedShape);
            }
            
            addPointAt(worldPos) {
                if (!this.selectedShape || !this.selectedShape.points) return;
                
                // –ù–∞—Ö–æ–¥–∏–º –±–ª–∏–∂–∞–π—à–∏–π —Å–µ–≥–º–µ–Ω—Ç
                let insertIndex = this.selectedShape.points.length;
                let minDistance = Infinity;
                
                for (let i = 0; i < this.selectedShape.points.length - 1; i++) {
                    const p1 = this.selectedShape.points[i];
                    const p2 = this.selectedShape.points[i + 1];
                    const distance = this.pointToLineDistance(worldPos, p1, p2);
                    
                    if (distance < minDistance && distance < 20) {
                        minDistance = distance;
                        insertIndex = i + 1;
                    }
                }
                
                if (insertIndex <= this.selectedShape.points.length) {
                    this.selectedShape.points.splice(insertIndex, 0, {x: worldPos.x, y: worldPos.y});
                    this.clearControlPoints();
                    this.createControlPoints(this.selectedShape);
                    this.render();
                }
            }
            
            deletePointAt(worldPos) {
                if (!this.selectedShape || !this.selectedShape.points) return;
                
                for (let i = 0; i < this.selectedShape.points.length; i++) {
                    const point = this.selectedShape.points[i];
                    const distance = Math.sqrt(Math.pow(worldPos.x - point.x, 2) + Math.pow(worldPos.y - point.y, 2));
                    
                    if (distance < 10 && this.selectedShape.points.length > 2) {
                        this.selectedShape.points.splice(i, 1);
                        this.clearControlPoints();
                        this.createControlPoints(this.selectedShape);
                        this.render();
                        break;
                    }
                }
            }
            
            pointToLineDistance(point, lineStart, lineEnd) {
                const A = point.x - lineStart.x;
                const B = point.y - lineStart.y;
                const C = lineEnd.x - lineStart.x;
                const D = lineEnd.y - lineStart.y;
                
                const dot = A * C + B * D;
                const lenSq = C * C + D * D;
                let param = -1;
                
                if (lenSq !== 0) param = dot / lenSq;
                
                let xx, yy;
                
                if (param < 0) {
                    xx = lineStart.x;
                    yy = lineStart.y;
                } else if (param > 1) {
                    xx = lineEnd.x;
                    yy = lineEnd.y;
                } else {
                    xx = lineStart.x + param * C;
                    yy = lineStart.y + param * D;
                }
                
                const dx = point.x - xx;
                const dy = point.y - yy;
                return Math.sqrt(dx * dx + dy * dy);
            }
            
            getShapeAt(worldPos) {
                for (let i = this.shapes.length - 1; i >= 0; i--) {
                    const shape = this.shapes[i];
                    if (this.isPointInShape(worldPos, shape)) {
                        return shape;
                    }
                }
                return null;
            }
            
            isPointInShape(worldPos, shape) {
                try {
                    switch (shape.type) {
                        case 'rectangle':
                            return worldPos.x >= shape.x && worldPos.x <= shape.x + shape.width &&
                                   worldPos.y >= shape.y && worldPos.y <= shape.y + shape.height;
                        case 'circle':
                            return Math.sqrt(Math.pow(worldPos.x - shape.x, 2) + Math.pow(worldPos.y - shape.y, 2)) <= shape.radius;
                        case 'line':
                        case 'pen':
                        case 'bezier':
                            const bounds = this.getShapeBounds(shape);
                            return worldPos.x >= bounds.x && worldPos.x <= bounds.x + bounds.width &&
                                   worldPos.y >= bounds.y && worldPos.y <= bounds.y + bounds.height;
                    }
                } catch (error) {
                    console.error('Error checking point in shape:', error);
                    return false;
                }
                return false;
            }
            
            getShapeBounds(shape) {
                let points = [];
                
                if (shape.type === 'rectangle') {
                    points = [
                        {x: shape.x, y: shape.y},
                        {x: shape.x + shape.width, y: shape.y},
                        {x: shape.x + shape.width, y: shape.y + shape.height},
                        {x: shape.x, y: shape.y + shape.height}
                    ];
                } else if (shape.type === 'circle') {
                    points = [
                        {x: shape.x - shape.radius, y: shape.y - shape.radius},
                        {x: shape.x + shape.radius, y: shape.y + shape.radius}
                    ];
                } else if (shape.points) {
                    points = shape.points;
                }
                
                if (points.length === 0) return {x: 0, y: 0, width: 0, height: 0};
                
                let minX = points[0].x, minY = points[0].y;
                let maxX = points[0].x, maxY = points[0].y;
                
                points.forEach(point => {
                    minX = Math.min(minX, point.x);
                    minY = Math.min(minY, point.y);
                    maxX = Math.max(maxX, point.x);
                    maxY = Math.max(maxY, point.y);
                });
                
                return {
                    x: minX,
                    y: minY,
                    width: maxX - minX,
                    height: maxY - minY
                };
            }
            
            // –û–ø–µ—Ä–∞—Ü–∏–∏ —Å —Ñ–∏–≥—É—Ä–∞–º–∏
            copyShape() {
                if (this.selectedShape) {
                    this.clipboard = JSON.parse(JSON.stringify(this.selectedShape));
                    alert('–§–∏–≥—É—Ä–∞ —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∞!');
                }
            }
            
            pasteShape() {
                if (this.clipboard) {
                    const newShape = JSON.parse(JSON.stringify(this.clipboard));
                    newShape.id = Date.now();
                    // –°–º–µ—â–∞–µ–º –Ω–æ–≤—É—é —Ñ–∏–≥—É—Ä—É
                    if (newShape.type === 'rectangle') {
                        newShape.x += 20;
                        newShape.y += 20;
                    } else if (newShape.type === 'circle') {
                        newShape.x += 20;
                        newShape.y += 20;
                    } else if (newShape.points) {
                        newShape.points.forEach(point => {
                            point.x += 20;
                            point.y += 20;
                        });
                    }
                    
                    this.shapes.push(newShape);
                    this.selectedShape = newShape;
                    this.clearControlPoints();
                    this.createControlPoints(newShape);
                    this.updateSelectionInfo();
                    this.render();
                }
            }
            
            deleteShape() {
                if (this.selectedShape) {
                    const index = this.shapes.indexOf(this.selectedShape);
                    if (index > -1) {
                        this.shapes.splice(index, 1);
                        this.selectedShape = null;
                        this.clearControlPoints();
                        this.updateSelectionInfo();
                        this.render();
                    }
                }
            }
            
            clearAll() {
                if (confirm('–£–¥–∞–ª–∏—Ç—å –≤—Å–µ —Ñ–∏–≥—É—Ä—ã?')) {
                    this.shapes = [];
                    this.selectedShape = null;
                    this.clearControlPoints();
                    this.updateSelectionInfo();
                    this.render();
                }
            }
            
            newProject() {
                if (confirm('–°–æ–∑–¥–∞—Ç—å –Ω–æ–≤—ã–π –ø—Ä–æ–µ–∫—Ç?')) {
                    this.shapes = [];
                    this.selectedShape = null;
                    this.clearControlPoints();
                    this.referenceImage.style.display = 'none';
                    this.updateSelectionInfo();
                    this.render();
                }
            }
            
            // –†–µ–Ω–¥–µ—Ä–∏–Ω–≥
            render() {
                this.ctx.save();
                this.ctx.setTransform(1, 0, 0, 1, 0, 0);
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                this.ctx.restore();
                
                this.ctx.save();
                this.ctx.translate(this.offsetX, this.offsetY);
                this.ctx.scale(this.scale, this.scale);
                
                // –†–µ–Ω–¥–µ—Ä–∏–º —Ñ–∏–≥—É—Ä—ã
                this.shapes.forEach(shape => {
                    this.drawShape(shape);
                });
                
                // –†–µ–Ω–¥–µ—Ä–∏–º —Ç–µ–∫—É—â—É—é —Ñ–∏–≥—É—Ä—É
                if (this.currentShape) {
                    this.drawShape(this.currentShape);
                }
                
                // –†–µ–Ω–¥–µ—Ä–∏–º –≤—ã–¥–µ–ª–µ–Ω–∏–µ
                if (this.selectedShape) {
                    this.drawSelection(this.selectedShape);
                }
                
                this.ctx.restore();
            }
            
            drawShape(shape) {
                try {
                    this.ctx.strokeStyle = shape.color;
                    this.ctx.lineWidth = shape.strokeWidth;
                    this.ctx.lineCap = 'round';
                    this.ctx.lineJoin = 'round';
                    
                    switch (shape.type) {
                        case 'pen':
                            this.drawPen(shape);
                            break;
                        case 'line':
                            this.drawLine(shape);
                            break;
                        case 'rectangle':
                            this.drawRectangle(shape);
                            break;
                        case 'circle':
                            this.drawCircle(shape);
                            break;
                        case 'bezier':
                            this.drawBezier(shape);
                            break;
                    }
                } catch (error) {
                    console.error('Error drawing shape:', error);
                }
            }
            
            drawPen(shape) {
                if (!shape.points || shape.points.length < 2) return;
                
                this.ctx.beginPath();
                this.ctx.moveTo(shape.points[0].x, shape.points[0].y);
                
                for (let i = 1; i < shape.points.length; i++) {
                    this.ctx.lineTo(shape.points[i].x, shape.points[i].y);
                }
                
                this.ctx.stroke();
            }
            
            drawLine(shape) {
                if (!shape.points || shape.points.length < 2) return;
                
                this.ctx.beginPath();
                this.ctx.moveTo(shape.points[0].x, shape.points[0].y);
                this.ctx.lineTo(shape.points[1].x, shape.points[1].y);
                this.ctx.stroke();
            }
            
            drawRectangle(shape) {
                this.ctx.strokeRect(shape.x, shape.y, shape.width, shape.height);
            }
            
            drawCircle(shape) {
                this.ctx.beginPath();
                this.ctx.arc(shape.x, shape.y, shape.radius, 0, 2 * Math.PI);
                this.ctx.stroke();
            }
            
            drawBezier(shape) {
                if (!shape.points || shape.points.length < 2) return;
                
                this.ctx.beginPath();
                this.ctx.moveTo(shape.points[0].x, shape.points[0].y);
                
                if (shape.controlPoints && shape.controlPoints.length >= 2) {
                    this.ctx.bezierCurveTo(
                        shape.controlPoints[0].x, shape.controlPoints[0].y,
                        shape.controlPoints[1].x, shape.controlPoints[1].y,
                        shape.points[1].x, shape.points[1].y
                    );
                } else {
                    this.ctx.lineTo(shape.points[1].x, shape.points[1].y);
                }
                
                this.ctx.stroke();
            }
            
            drawSelection(shape) {
                try {
                    const bounds = this.getShapeBounds(shape);
                    this.ctx.strokeStyle = '#00ffff';
                    this.ctx.lineWidth = 1;
                    this.ctx.setLineDash([5, 5]);
                    this.ctx.strokeRect(bounds.x - 5, bounds.y - 5, bounds.width + 10, bounds.height + 10);
                    this.ctx.setLineDash([]);
                } catch (error) {
                    console.error('Error drawing selection:', error);
                }
            }
            
            updateToolInfo() {
                const toolNames = {
                    'select': '–í—ã–¥–µ–ª–µ–Ω–∏–µ',
                    'move': '–ü–µ—Ä–µ–º–µ—â–µ–Ω–∏–µ',
                    'pen': '–ü–µ—Ä–æ',
                    'line': '–õ–∏–Ω–∏—è',
                    'rectangle': '–ü—Ä—è–º–æ—É–≥–æ–ª—å–Ω–∏–∫',
                    'circle': '–ö—Ä—É–≥',
                    'bezier': '–ö—Ä–∏–≤–∞—è –ë–µ–∑—å–µ',
                    'add-point': '–î–æ–±–∞–≤–∏—Ç—å —Ç–æ—á–∫—É',
                    'delete-point': '–£–¥–∞–ª–∏—Ç—å —Ç–æ—á–∫—É'
                };
                document.getElementById('toolInfo').textContent = '–ò–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç: ' + toolNames[this.currentTool];
            }
            
            updateSelectionInfo() {
                document.getElementById('selectionInfo').textContent = 
                    this.selectedShape ? '–í—ã–¥–µ–ª–µ–Ω–æ' : '–ù–µ –≤—ã–¥–µ–ª–µ–Ω–æ';
            }
            
            updateZoomInfo() {
                document.getElementById('zoomInfo').textContent = '–ú–∞—Å—à—Ç–∞–±: ' + Math.round(this.scale * 100) + '%';
            }
            
            updateCursorPos(e) {
                const canvasPos = this.getPointerPos(e);
                const worldPos = this.getWorldPos(canvasPos);
                document.getElementById('cursorPos').textContent = 
                    `X:${Math.round(worldPos.x)} Y:${Math.round(worldPos.y)}`;
            }
            
            // –§–∞–π–ª–æ–≤—ã–µ –æ–ø–µ—Ä–∞—Ü–∏–∏
            handleImageSelect(e) {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        this.selectedImageData = event.target.result;
                    };
                    reader.readAsDataURL(file);
                }
            }
            
            loadSelectedImage() {
                if (this.selectedImageData) {
                    this.referenceImage.src = this.selectedImageData;
                    this.referenceImage.style.display = 'block';
                    this.referenceImage.style.opacity = this.imageOpacity;
                    
                    // –¶–µ–Ω—Ç—Ä–∏—Ä—É–µ–º –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ
                    this.referenceImage.onload = () => {
                        const imgAspect = this.referenceImage.naturalWidth / this.referenceImage.naturalHeight;
                        const canvasAspect = this.canvas.width / this.canvas.height;
                        
                        let displayWidth, displayHeight;
                        
                        if (imgAspect > canvasAspect) {
                            displayWidth = this.canvas.width;
                            displayHeight = this.canvas.width / imgAspect;
                        } else {
                            displayHeight = this.canvas.height;
                            displayWidth = this.canvas.height * imgAspect;
                        }
                        
                        this.referenceImage.style.width = displayWidth + 'px';
                        this.referenceImage.style.height = displayHeight + 'px';
                        this.referenceImage.style.left = ((this.canvas.width - displayWidth) / 2) + 'px';
                        this.referenceImage.style.top = ((this.canvas.height - displayHeight) / 2) + 'px';
                        
                        this.updateReferenceImagePosition();
                    };
                    
                    this.hideModal('loadImageModal');
                    this.render();
                } else {
                    alert('–°–Ω–∞—á–∞–ª–∞ –≤—ã–±–µ—Ä–∏—Ç–µ —Ñ–∞–π–ª!');
                }
            }
            
            saveProject() {
                const project = {
                    shapes: this.shapes,
                    image: this.referenceImage.src,
                    timestamp: new Date().toISOString()
                };
                
                const data = JSON.stringify(project, null, 2);
                const blob = new Blob([data], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                
                const a = document.createElement('a');
                a.href = url;
                a.download = 'vector-project.json';
                a.click();
                
                URL.revokeObjectURL(url);
            }
            
            showModal(modalId) {
                document.getElementById(modalId).style.display = 'flex';
            }
            
            hideModal(modalId) {
                document.getElementById(modalId).style.display = 'none';
            }
        }

        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è
        document.addEventListener('DOMContentLoaded', () => {
            new VectorEditor();
        });

        // –ë–ª–æ–∫–∏—Ä—É–µ–º –∫–æ–Ω—Ç–µ–∫—Å—Ç–Ω–æ–µ –º–µ–Ω—é
        document.addEventListener('contextmenu', (e) => e.preventDefault());
    </script>
</body>
</html>