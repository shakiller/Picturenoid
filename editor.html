<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vector Editor</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, sans-serif;
            background: #1a1a2e;
            color: white;
            overflow: hidden;
        }

        .app-container {
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        /* –í–µ—Ä—Ö–Ω—è—è –ø–∞–Ω–µ–ª—å */
        .top-bar {
            background: #16213e;
            padding: 8px;
            border-bottom: 2px solid #0f3460;
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
            min-height: 50px;
            align-items: center;
        }

        .btn {
            background: #e94560;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            min-width: 44px;
            min-height: 44px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .btn:active {
            background: #ff6b81;
        }

        .btn-secondary {
            background: #0f3460;
        }

        /* –û—Å–Ω–æ–≤–Ω–∞—è –æ–±–ª–∞—Å—Ç—å */
        .main-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            position: relative;
            overflow: hidden;
        }

        /* –ü–∞–Ω–µ–ª—å –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤ */
        .tools-panel {
            background: #16213e;
            padding: 8px;
            border-bottom: 1px solid #0f3460;
            display: flex;
            gap: 5px;
            overflow-x: auto;
            min-height: 50px;
        }

        .tool {
            background: #1a1a2e;
            border: 2px solid #e94560;
            border-radius: 8px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 20px;
            min-width: 44px;
            min-height: 44px;
            flex-shrink: 0;
        }

        .tool.active {
            background: #e94560;
        }

        /* –û–±–ª–∞—Å—Ç—å —Ä–∏—Å–æ–≤–∞–Ω–∏—è */
        .canvas-container {
            flex: 1;
            position: relative;
            background: #2d2d44;
            overflow: hidden;
            background-image: 
                linear-gradient(#333 1px, transparent 1px),
                linear-gradient(90deg, #333 1px, transparent 1px);
            background-size: 20px 20px;
        }

        #drawingCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            cursor: crosshair;
        }

        /* –ù–∏–∂–Ω—è—è –ø–∞–Ω–µ–ª—å */
        .bottom-panel {
            background: #16213e;
            padding: 8px;
            border-top: 1px solid #0f3460;
            display: flex;
            gap: 10px;
            overflow-x: auto;
            min-height: 50px;
            align-items: center;
        }

        .property-group {
            display: flex;
            align-items: center;
            gap: 5px;
            flex-shrink: 0;
        }

        .property-label {
            font-size: 12px;
            color: #e94560;
            white-space: nowrap;
        }

        .color-palette {
            display: flex;
            gap: 3px;
        }

        .color {
            width: 24px;
            height: 24px;
            border: 2px solid transparent;
            border-radius: 4px;
            cursor: pointer;
        }

        .color.active {
            border-color: white;
        }

        .slider {
            width: 60px;
            height: 4px;
        }

        select {
            padding: 6px;
            border-radius: 4px;
            border: 1px solid #e94560;
            background: #1a1a2e;
            color: white;
            font-size: 12px;
        }

        /* –¢–æ—á–∫–∏ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è */
        .control-point {
            position: absolute;
            width: 12px;
            height: 12px;
            background: #00ffff;
            border: 2px solid #006666;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            cursor: move;
            z-index: 1000;
        }

        .control-handle {
            position: absolute;
            width: 8px;
            height: 8px;
            background: #ff00ff;
            border: 2px solid #660066;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            cursor: pointer;
            z-index: 900;
        }

        /* –ú–æ–¥–∞–ª—å–Ω—ã–µ –æ–∫–Ω–∞ */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.9);
            z-index: 10000;
            align-items: center;
            justify-content: center;
        }

        .modal-content {
            background: #16213e;
            padding: 20px;
            border-radius: 10px;
            width: 90%;
            max-width: 400px;
            border: 2px solid #e94560;
        }

        .modal-buttons {
            display: flex;
            gap: 8px;
            margin-top: 15px;
            flex-wrap: wrap;
        }

        .file-input {
            display: none;
        }

        /* –°—Ç–∞—Ç—É—Å –±–∞—Ä */
        .status-bar {
            background: #0f3460;
            padding: 5px 10px;
            font-size: 11px;
            display: flex;
            justify-content: space-between;
            min-height: 30px;
            align-items: center;
        }
    </style>
</head>
<body>
    <div class="app-container">
        <!-- –í–µ—Ä—Ö–Ω—è—è –ø–∞–Ω–µ–ª—å -->
        <div class="top-bar">
            <button class="btn btn-secondary" id="loadImageBtn">üìÅ</button>
            <button class="btn" id="saveBtn">üíæ</button>
            <button class="btn btn-secondary" id="newBtn">üÜï</button>
            <button class="btn btn-secondary" id="copyBtn">üìã</button>
            <button class="btn btn-secondary" id="pasteBtn">üìÑ</button>
            <button class="btn btn-secondary" id="deleteBtn">üóëÔ∏è</button>
        </div>

        <!-- –û—Å–Ω–æ–≤–Ω–∞—è –æ–±–ª–∞—Å—Ç—å -->
        <div class="main-area">
            <!-- –ü–∞–Ω–µ–ª—å –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤ -->
            <div class="tools-panel">
                <div class="tool active" data-tool="select" title="–í—ã–¥–µ–ª–µ–Ω–∏–µ">‚Üñ</div>
                <div class="tool" data-tool="move" title="–ü–µ—Ä–µ–º–µ—â–µ–Ω–∏–µ">‚ú•</div>
                <div class="tool" data-tool="pen" title="–ü–µ—Ä–æ">‚úèÔ∏è</div>
                <div class="tool" data-tool="line" title="–õ–∏–Ω–∏—è">üìè</div>
                <div class="tool" data-tool="rectangle" title="–ü—Ä—è–º–æ—É–≥–æ–ª—å–Ω–∏–∫">‚ñ°</div>
                <div class="tool" data-tool="circle" title="–ö—Ä—É–≥">‚óã</div>
                <div class="tool" data-tool="bezier" title="–ö—Ä–∏–≤–∞—è –ë–µ–∑—å–µ">‚éå</div>
                <div class="tool" data-tool="add-point" title="–î–æ–±–∞–≤–∏—Ç—å —Ç–æ—á–∫—É">‚äï</div>
                <div class="tool" data-tool="delete-point" title="–£–¥–∞–ª–∏—Ç—å —Ç–æ—á–∫—É">‚äñ</div>
            </div>

            <!-- –û–±–ª–∞—Å—Ç—å —Ä–∏—Å–æ–≤–∞–Ω–∏—è -->
            <div class="canvas-container" id="canvasContainer">
                <canvas id="drawingCanvas"></canvas>
            </div>

            <!-- –ù–∏–∂–Ω—è—è –ø–∞–Ω–µ–ª—å -->
            <div class="bottom-panel">
                <div class="property-group">
                    <div class="property-label">–¶–≤–µ—Ç:</div>
                    <div class="color-palette">
                        <div class="color active" style="background: #ff0000;" data-color="#ff0000"></div>
                        <div class="color" style="background: #00ff00;" data-color="#00ff00"></div>
                        <div class="color" style="background: #0000ff;" data-color="#0000ff"></div>
                        <div class="color" style="background: #ffff00;" data-color="#ffff00"></div>
                    </div>
                </div>

                <div class="property-group">
                    <div class="property-label">–¢–æ–ª—â:</div>
                    <input type="range" class="slider" id="strokeWidth" min="1" max="10" value="2">
                    <span style="font-size: 11px;">2</span>
                </div>

                <div class="property-group">
                    <div class="property-label">–£–¥–∞–ª–∏—Ç—å –≤—Å—ë</div>
                    <button class="btn" style="padding: 5px; font-size: 10px;" id="clearAllBtn">üóëÔ∏è</button>
                </div>
            </div>
        </div>

        <!-- –°—Ç–∞—Ç—É—Å –±–∞—Ä -->
        <div class="status-bar">
            <span id="cursorPos">X:0 Y:0</span>
            <span id="toolInfo">–ò–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç: –í—ã–¥–µ–ª–µ–Ω–∏–µ</span>
            <span id="selectionInfo">–ù–µ –≤—ã–¥–µ–ª–µ–Ω–æ</span>
        </div>
    </div>

    <!-- –ú–æ–¥–∞–ª—å–Ω—ã–µ –æ–∫–Ω–∞ -->
    <div class="modal" id="loadImageModal">
        <div class="modal-content">
            <div style="text-align: center; margin-bottom: 15px; color: #e94560;">–ó–∞–≥—Ä—É–∑–∏—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ</div>
            <input type="file" id="imageInput" class="file-input" accept="image/*">
            <div class="modal-buttons">
                <button class="btn btn-secondary" onclick="document.getElementById('imageInput').click()">
                    –í—ã–±—Ä–∞—Ç—å
                </button>
                <button class="btn" id="confirmLoadBtn">
                    –ó–∞–≥—Ä—É–∑–∏—Ç—å
                </button>
                <button class="btn btn-secondary" id="cancelLoadBtn">
                    –û—Ç–º–µ–Ω–∞
                </button>
            </div>
        </div>
    </div>

    <script>
        class VectorEditor {
            constructor() {
                this.canvas = document.getElementById('drawingCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.container = document.getElementById('canvasContainer');
                
                // –°–æ—Å—Ç–æ—è–Ω–∏–µ —Ä–µ–¥–∞–∫—Ç–æ—Ä–∞
                this.currentTool = 'select';
                this.currentColor = '#ff0000';
                this.strokeWidth = 2;
                
                // –î–∞–Ω–Ω—ã–µ
                this.shapes = [];
                this.currentShape = null;
                this.selectedShape = null;
                this.clipboard = null;
                this.controlPoints = [];
                
                // –í—Ä–µ–º–µ–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
                this.isDrawing = false;
                this.startPos = {x: 0, y: 0};
                this.lastPos = {x: 0, y: 0};
                this.selectedPoint = null;
                
                this.init();
            }
            
            init() {
                this.setupCanvas();
                this.setupEventListeners();
                this.setupModals();
                this.render();
            }
            
            setupCanvas() {
                this.resizeCanvas();
                window.addEventListener('resize', () => this.resizeCanvas());
            }
            
            resizeCanvas() {
                const rect = this.container.getBoundingClientRect();
                this.canvas.width = rect.width;
                this.canvas.height = rect.height;
                this.render();
            }
            
            setupEventListeners() {
                // –ò–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã
                document.querySelectorAll('.tool').forEach(tool => {
                    tool.addEventListener('click', (e) => {
                        document.querySelectorAll('.tool').forEach(t => t.classList.remove('active'));
                        e.currentTarget.classList.add('active');
                        this.currentTool = e.currentTarget.dataset.tool;
                        this.clearControlPoints();
                        if (this.selectedShape) {
                            this.createControlPoints(this.selectedShape);
                        }
                        this.updateToolInfo();
                    });
                });
                
                // –¶–≤–µ—Ç–∞
                document.querySelectorAll('.color').forEach(color => {
                    color.addEventListener('click', (e) => {
                        document.querySelectorAll('.color').forEach(c => c.classList.remove('active'));
                        e.currentTarget.classList.add('active');
                        this.currentColor = e.currentTarget.dataset.color;
                    });
                });
                
                // –°–ª–∞–π–¥–µ—Ä
                document.getElementById('strokeWidth').addEventListener('input', (e) => {
                    this.strokeWidth = parseInt(e.target.value);
                    e.target.nextElementSibling.textContent = this.strokeWidth;
                });
                
                // –ö–Ω–æ–ø–∫–∏
                document.getElementById('newBtn').addEventListener('click', () => this.newProject());
                document.getElementById('copyBtn').addEventListener('click', () => this.copyShape());
                document.getElementById('pasteBtn').addEventListener('click', () => this.pasteShape());
                document.getElementById('deleteBtn').addEventListener('click', () => this.deleteShape());
                document.getElementById('clearAllBtn').addEventListener('click', () => this.clearAll());
                
                // –°–æ–±—ã—Ç–∏—è –º—ã—à–∏ –∏ –∫–∞—Å–∞–Ω–∏—è
                this.canvas.addEventListener('mousedown', (e) => this.onPointerStart(e));
                this.canvas.addEventListener('mousemove', (e) => this.onPointerMove(e));
                this.canvas.addEventListener('mouseup', (e) => this.onPointerEnd(e));
                
                this.canvas.addEventListener('touchstart', (e) => this.onPointerStart(e));
                this.canvas.addEventListener('touchmove', (e) => this.onPointerMove(e));
                this.canvas.addEventListener('touchend', (e) => this.onPointerEnd(e));
                
                // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø–æ–∑–∏—Ü–∏–∏ –∫—É—Ä—Å–æ—Ä–∞
                this.canvas.addEventListener('mousemove', (e) => this.updateCursorPos(e));
                this.canvas.addEventListener('touchmove', (e) => this.updateCursorPos(e));
            }
            
            setupModals() {
                document.getElementById('loadImageBtn').addEventListener('click', () => {
                    this.showModal('loadImageModal');
                });
                
                document.getElementById('saveBtn').addEventListener('click', () => {
                    this.saveProject();
                });
                
                document.getElementById('imageInput').addEventListener('change', (e) => this.handleImageSelect(e));
                document.getElementById('confirmLoadBtn').addEventListener('click', () => this.loadSelectedImage());
                document.getElementById('cancelLoadBtn').addEventListener('click', () => this.hideModal('loadImageModal'));
            }
            
            getPointerPos(e) {
                const rect = this.canvas.getBoundingClientRect();
                let clientX, clientY;
                
                if (e.touches) {
                    clientX = e.touches[0].clientX;
                    clientY = e.touches[0].clientY;
                } else {
                    clientX = e.clientX;
                    clientY = e.clientY;
                }
                
                return {
                    x: clientX - rect.left,
                    y: clientY - rect.top
                };
            }
            
            onPointerStart(e) {
                e.preventDefault();
                const pos = this.getPointerPos(e);
                this.startPos = {...pos};
                this.lastPos = {...pos};
                
                // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ç–æ—á–∫–∏ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è
                const controlPoint = this.getControlPointAt(pos);
                if (controlPoint) {
                    this.selectedPoint = controlPoint;
                    return;
                }
                
                // –ü—Ä–æ–≤–µ—Ä—è–µ–º –≤—ã–¥–µ–ª–µ–Ω–∏–µ —Ñ–∏–≥—É—Ä—ã
                const shape = this.getShapeAt(pos);
                if (this.currentTool === 'select' || this.currentTool === 'move') {
                    this.selectedShape = shape;
                    this.clearControlPoints();
                    if (this.selectedShape) {
                        this.createControlPoints(this.selectedShape);
                    }
                    this.updateSelectionInfo();
                    this.render();
                    return;
                }
                
                // –£–¥–∞–ª–µ–Ω–∏–µ —Ç–æ—á–∫–∏
                if (this.currentTool === 'delete-point' && this.selectedShape) {
                    this.deletePointAt(pos);
                    return;
                }
                
                // –î–æ–±–∞–≤–ª–µ–Ω–∏–µ —Ç–æ—á–∫–∏
                if (this.currentTool === 'add-point' && this.selectedShape) {
                    this.addPointAt(pos);
                    return;
                }
                
                // –ù–∞—á–∏–Ω–∞–µ–º —Ä–∏—Å–æ–≤–∞–Ω–∏–µ –Ω–æ–≤–æ–π —Ñ–∏–≥—É—Ä—ã
                this.startNewShape(pos);
            }
            
            onPointerMove(e) {
                e.preventDefault();
                const pos = this.getPointerPos(e);
                
                if (this.selectedPoint) {
                    this.moveControlPoint(pos);
                } else if (this.currentTool === 'move' && this.selectedShape && this.isDrawing) {
                    this.moveShape(pos);
                } else if (this.isDrawing && this.currentShape) {
                    this.updateCurrentShape(pos);
                }
                
                this.lastPos = {...pos};
                this.render();
            }
            
            onPointerEnd(e) {
                if (this.isDrawing && this.currentShape) {
                    this.finalizeShape();
                }
                this.selectedPoint = null;
                this.isDrawing = false;
            }
            
            // –°–æ–∑–¥–∞–Ω–∏–µ —Ñ–∏–≥—É—Ä
            startNewShape(pos) {
                this.currentShape = {
                    type: this.currentTool,
                    points: [{x: pos.x, y: pos.y}],
                    color: this.currentColor,
                    strokeWidth: this.strokeWidth,
                    id: Date.now()
                };
                
                if (this.currentTool === 'rectangle' || this.currentTool === 'circle') {
                    this.currentShape.x = pos.x;
                    this.currentShape.y = pos.y;
                    this.currentShape.width = 0;
                    this.currentShape.height = 0;
                }
                
                this.isDrawing = true;
            }
            
            updateCurrentShape(pos) {
                if (!this.currentShape) return;
                
                switch (this.currentShape.type) {
                    case 'pen':
                        this.currentShape.points.push({x: pos.x, y: pos.y});
                        break;
                    case 'line':
                        if (this.currentShape.points.length === 1) {
                            this.currentShape.points.push({x: pos.x, y: pos.y});
                        } else {
                            this.currentShape.points[1] = {x: pos.x, y: pos.y};
                        }
                        break;
                    case 'rectangle':
                        this.currentShape.width = pos.x - this.currentShape.x;
                        this.currentShape.height = pos.y - this.currentShape.y;
                        break;
                    case 'circle':
                        const radius = Math.sqrt(
                            Math.pow(pos.x - this.currentShape.x, 2) + 
                            Math.pow(pos.y - this.currentShape.y, 2)
                        );
                        this.currentShape.radius = radius;
                        break;
                    case 'bezier':
                        if (this.currentShape.points.length === 1) {
                            this.currentShape.points.push({x: pos.x, y: pos.y});
                            // –î–æ–±–∞–≤–ª—è–µ–º –∫–æ–Ω—Ç—Ä–æ–ª—å–Ω—ã–µ —Ç–æ—á–∫–∏
                            this.currentShape.controlPoints = [
                                {x: (this.currentShape.points[0].x + pos.x) / 2, y: this.currentShape.points[0].y},
                                {x: (this.currentShape.points[0].x + pos.x) / 2, y: pos.y}
                            ];
                        } else {
                            this.currentShape.points[1] = {x: pos.x, y: pos.y};
                        }
                        break;
                }
            }
            
            finalizeShape() {
                if (this.currentShape) {
                    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–π —Ä–∞–∑–º–µ—Ä
                    let shouldAdd = true;
                    
                    if (this.currentShape.type === 'rectangle') {
                        if (Math.abs(this.currentShape.width) < 5 || Math.abs(this.currentShape.height) < 5) {
                            shouldAdd = false;
                        }
                    } else if (this.currentShape.type === 'circle') {
                        if (this.currentShape.radius < 5) {
                            shouldAdd = false;
                        }
                    } else if (this.currentShape.points) {
                        if (this.currentShape.points.length < 2) {
                            shouldAdd = false;
                        }
                    }
                    
                    if (shouldAdd) {
                        this.shapes.push(this.currentShape);
                        this.selectedShape = this.currentShape;
                        this.createControlPoints(this.currentShape);
                        this.updateSelectionInfo();
                    }
                    
                    this.currentShape = null;
                }
            }
            
            // –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Ç–æ—á–∫–∞–º–∏
            createControlPoints(shape) {
                this.clearControlPoints();
                
                if (!shape) return;
                
                switch (shape.type) {
                    case 'rectangle':
                        this.createRectanglePoints(shape);
                        break;
                    case 'circle':
                        this.createCirclePoints(shape);
                        break;
                    case 'line':
                    case 'pen':
                    case 'bezier':
                        this.createPathPoints(shape);
                        break;
                }
            }
            
            createRectanglePoints(shape) {
                const points = [
                    {x: shape.x, y: shape.y},
                    {x: shape.x + shape.width, y: shape.y},
                    {x: shape.x + shape.width, y: shape.y + shape.height},
                    {x: shape.x, y: shape.y + shape.height}
                ];
                
                points.forEach((point, index) => {
                    this.createControlPoint(point, 'vertex', index);
                });
            }
            
            createCirclePoints(shape) {
                const points = [
                    {x: shape.x - shape.radius, y: shape.y},
                    {x: shape.x + shape.radius, y: shape.y},
                    {x: shape.x, y: shape.y - shape.radius},
                    {x: shape.x, y: shape.y + shape.radius}
                ];
                
                points.forEach((point, index) => {
                    this.createControlPoint(point, 'radius', index);
                });
            }
            
            createPathPoints(shape) {
                shape.points.forEach((point, index) => {
                    this.createControlPoint(point, 'vertex', index);
                });
                
                if (shape.controlPoints) {
                    shape.controlPoints.forEach((point, index) => {
                        this.createControlPoint(point, 'handle', index);
                    });
                }
            }
            
            createControlPoint(point, type, index) {
                const div = document.createElement('div');
                div.className = type === 'handle' ? 'control-handle' : 'control-point';
                div.style.left = point.x + 'px';
                div.style.top = point.y + 'px';
                div.dataset.type = type;
                div.dataset.index = index;
                
                this.container.appendChild(div);
                this.controlPoints.push(div);
            }
            
            clearControlPoints() {
                this.controlPoints.forEach(point => point.remove());
                this.controlPoints = [];
            }
            
            getControlPointAt(pos) {
                for (let point of this.controlPoints) {
                    const rect = point.getBoundingClientRect();
                    const pointX = rect.left + rect.width / 2;
                    const pointY = rect.top + rect.height / 2;
                    
                    const distance = Math.sqrt(
                        Math.pow(pos.x - pointX, 2) +
                        Math.pow(pos.y - pointY, 2)
                    );
                    
                    if (distance < 20) {
                        return {
                            element: point,
                            type: point.dataset.type,
                            index: parseInt(point.dataset.index)
                        };
                    }
                }
                return null;
            }
            
            moveControlPoint(pos) {
                if (!this.selectedPoint || !this.selectedShape) return;
                
                // –û–±–Ω–æ–≤–ª—è–µ–º –ø–æ–∑–∏—Ü–∏—é —ç–ª–µ–º–µ–Ω—Ç–∞
                this.selectedPoint.element.style.left = pos.x + 'px';
                this.selectedPoint.element.style.top = pos.y + 'px';
                
                // –û–±–Ω–æ–≤–ª—è–µ–º –¥–∞–Ω–Ω—ã–µ —Ñ–∏–≥—É—Ä—ã
                switch (this.selectedShape.type) {
                    case 'rectangle':
                        this.moveRectanglePoint(pos);
                        break;
                    case 'circle':
                        this.moveCirclePoint(pos);
                        break;
                    case 'line':
                    case 'pen':
                    case 'bezier':
                        this.movePathPoint(pos);
                        break;
                }
            }
            
            moveRectanglePoint(pos) {
                switch (this.selectedPoint.index) {
                    case 0: // –ª–µ–≤—ã–π –≤–µ—Ä—Ö–Ω–∏–π
                        this.selectedShape.width += this.selectedShape.x - pos.x;
                        this.selectedShape.height += this.selectedShape.y - pos.y;
                        this.selectedShape.x = pos.x;
                        this.selectedShape.y = pos.y;
                        break;
                    case 1: // –ø—Ä–∞–≤—ã–π –≤–µ—Ä—Ö–Ω–∏–π
                        this.selectedShape.width = pos.x - this.selectedShape.x;
                        this.selectedShape.height += this.selectedShape.y - pos.y;
                        this.selectedShape.y = pos.y;
                        break;
                    case 2: // –ø—Ä–∞–≤—ã–π –Ω–∏–∂–Ω–∏–π
                        this.selectedShape.width = pos.x - this.selectedShape.x;
                        this.selectedShape.height = pos.y - this.selectedShape.y;
                        break;
                    case 3: // –ª–µ–≤—ã–π –Ω–∏–∂–Ω–∏–π
                        this.selectedShape.width += this.selectedShape.x - pos.x;
                        this.selectedShape.height = pos.y - this.selectedShape.y;
                        this.selectedShape.x = pos.x;
                        break;
                }
            }
            
            moveCirclePoint(pos) {
                switch (this.selectedPoint.index) {
                    case 0: // –ª–µ–≤–∞—è
                        this.selectedShape.radius = this.selectedShape.x - pos.x;
                        break;
                    case 1: // –ø—Ä–∞–≤–∞—è
                        this.selectedShape.radius = pos.x - this.selectedShape.x;
                        break;
                    case 2: // –≤–µ—Ä—Ö–Ω—è—è
                        this.selectedShape.radius = this.selectedShape.y - pos.y;
                        break;
                    case 3: // –Ω–∏–∂–Ω—è—è
                        this.selectedShape.radius = pos.y - this.selectedShape.y;
                        break;
                }
                this.selectedShape.radius = Math.abs(this.selectedShape.radius);
            }
            
            movePathPoint(pos) {
                if (this.selectedPoint.type === 'vertex') {
                    this.selectedShape.points[this.selectedPoint.index] = {x: pos.x, y: pos.y};
                } else if (this.selectedPoint.type === 'handle') {
                    this.selectedShape.controlPoints[this.selectedPoint.index] = {x: pos.x, y: pos.y};
                }
            }
            
            moveShape(pos) {
                if (!this.selectedShape) return;
                
                const deltaX = pos.x - this.lastPos.x;
                const deltaY = pos.y - this.lastPos.y;
                
                switch (this.selectedShape.type) {
                    case 'rectangle':
                        this.selectedShape.x += deltaX;
                        this.selectedShape.y += deltaY;
                        break;
                    case 'circle':
                        this.selectedShape.x += deltaX;
                        this.selectedShape.y += deltaY;
                        break;
                    case 'line':
                    case 'pen':
                    case 'bezier':
                        this.selectedShape.points.forEach(point => {
                            point.x += deltaX;
                            point.y += deltaY;
                        });
                        if (this.selectedShape.controlPoints) {
                            this.selectedShape.controlPoints.forEach(point => {
                                point.x += deltaX;
                                point.y += deltaY;
                            });
                        }
                        break;
                }
                
                // –û–±–Ω–æ–≤–ª—è–µ–º —Ç–æ—á–∫–∏ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è
                this.clearControlPoints();
                this.createControlPoints(this.selectedShape);
            }
            
            addPointAt(pos) {
                if (!this.selectedShape || !this.selectedShape.points) return;
                
                // –ù–∞—Ö–æ–¥–∏–º –±–ª–∏–∂–∞–π—à–∏–π —Å–µ–≥–º–µ–Ω—Ç
                let insertIndex = this.selectedShape.points.length;
                let minDistance = Infinity;
                
                for (let i = 0; i < this.selectedShape.points.length - 1; i++) {
                    const p1 = this.selectedShape.points[i];
                    const p2 = this.selectedShape.points[i + 1];
                    const distance = this.pointToLineDistance(pos, p1, p2);
                    
                    if (distance < minDistance && distance < 20) {
                        minDistance = distance;
                        insertIndex = i + 1;
                    }
                }
                
                if (insertIndex <= this.selectedShape.points.length) {
                    this.selectedShape.points.splice(insertIndex, 0, {x: pos.x, y: pos.y});
                    this.clearControlPoints();
                    this.createControlPoints(this.selectedShape);
                }
            }
            
            deletePointAt(pos) {
                if (!this.selectedShape || !this.selectedShape.points) return;
                
                for (let i = 0; i < this.selectedShape.points.length; i++) {
                    const point = this.selectedShape.points[i];
                    const distance = Math.sqrt(Math.pow(pos.x - point.x, 2) + Math.pow(pos.y - point.y, 2));
                    
                    if (distance < 10 && this.selectedShape.points.length > 2) {
                        this.selectedShape.points.splice(i, 1);
                        this.clearControlPoints();
                        this.createControlPoints(this.selectedShape);
                        break;
                    }
                }
            }
            
            pointToLineDistance(point, lineStart, lineEnd) {
                const A = point.x - lineStart.x;
                const B = point.y - lineStart.y;
                const C = lineEnd.x - lineStart.x;
                const D = lineEnd.y - lineStart.y;
                
                const dot = A * C + B * D;
                const lenSq = C * C + D * D;
                let param = -1;
                
                if (lenSq !== 0) param = dot / lenSq;
                
                let xx, yy;
                
                if (param < 0) {
                    xx = lineStart.x;
                    yy = lineStart.y;
                } else if (param > 1) {
                    xx = lineEnd.x;
                    yy = lineEnd.y;
                } else {
                    xx = lineStart.x + param * C;
                    yy = lineStart.y + param * D;
                }
                
                const dx = point.x - xx;
                const dy = point.y - yy;
                return Math.sqrt(dx * dx + dy * dy);
            }
            
            getShapeAt(pos) {
                for (let i = this.shapes.length - 1; i >= 0; i--) {
                    const shape = this.shapes[i];
                    if (this.isPointInShape(pos, shape)) {
                        return shape;
                    }
                }
                return null;
            }
            
            isPointInShape(pos, shape) {
                switch (shape.type) {
                    case 'rectangle':
                        return pos.x >= shape.x && pos.x <= shape.x + shape.width &&
                               pos.y >= shape.y && pos.y <= shape.y + shape.height;
                    case 'circle':
                        return Math.sqrt(Math.pow(pos.x - shape.x, 2) + Math.pow(pos.y - shape.y, 2)) <= shape.radius;
                    case 'line':
                    case 'pen':
                    case 'bezier':
                        const bounds = this.getShapeBounds(shape);
                        return pos.x >= bounds.x && pos.x <= bounds.x + bounds.width &&
                               pos.y >= bounds.y && pos.y <= bounds.y + bounds.height;
                }
                return false;
            }
            
            getShapeBounds(shape) {
                let points = [];
                
                if (shape.type === 'rectangle') {
                    points = [
                        {x: shape.x, y: shape.y},
                        {x: shape.x + shape.width, y: shape.y},
                        {x: shape.x + shape.width, y: shape.y + shape.height},
                        {x: shape.x, y: shape.y + shape.height}
                    ];
                } else if (shape.type === 'circle') {
                    points = [
                        {x: shape.x - shape.radius, y: shape.y - shape.radius},
                        {x: shape.x + shape.radius, y: shape.y + shape.radius}
                    ];
                } else if (shape.points) {
                    points = shape.points;
                }
                
                if (points.length === 0) return {x: 0, y: 0, width: 0, height: 0};
                
                let minX = points[0].x, minY = points[0].y;
                let maxX = points[0].x, maxY = points[0].y;
                
                points.forEach(point => {
                    minX = Math.min(minX, point.x);
                    minY = Math.min(minY, point.y);
                    maxX = Math.max(maxX, point.x);
                    maxY = Math.max(maxY, point.y);
                });
                
                return {
                    x: minX,
                    y: minY,
                    width: maxX - minX,
                    height: maxY - minY
                };
            }
            
            // –û–ø–µ—Ä–∞—Ü–∏–∏ —Å —Ñ–∏–≥—É—Ä–∞–º–∏
            copyShape() {
                if (this.selectedShape) {
                    this.clipboard = JSON.parse(JSON.stringify(this.selectedShape));
                }
            }
            
            pasteShape() {
                if (this.clipboard) {
                    const newShape = JSON.parse(JSON.stringify(this.clipboard));
                    newShape.id = Date.now();
                    // –°–º–µ—â–∞–µ–º –Ω–æ–≤—É—é —Ñ–∏–≥—É—Ä—É
                    if (newShape.type === 'rectangle') {
                        newShape.x += 20;
                        newShape.y += 20;
                    } else if (newShape.type === 'circle') {
                        newShape.x += 20;
                        newShape.y += 20;
                    } else if (newShape.points) {
                        newShape.points.forEach(point => {
                            point.x += 20;
                            point.y += 20;
                        });
                    }
                    
                    this.shapes.push(newShape);
                    this.selectedShape = newShape;
                    this.clearControlPoints();
                    this.createControlPoints(newShape);
                    this.updateSelectionInfo();
                    this.render();
                }
            }
            
            deleteShape() {
                if (this.selectedShape) {
                    const index = this.shapes.indexOf(this.selectedShape);
                    if (index > -1) {
                        this.shapes.splice(index, 1);
                        this.selectedShape = null;
                        this.clearControlPoints();
                        this.updateSelectionInfo();
                        this.render();
                    }
                }
            }
            
            clearAll() {
                if (confirm('–£–¥–∞–ª–∏—Ç—å –≤—Å–µ —Ñ–∏–≥—É—Ä—ã?')) {
                    this.shapes = [];
                    this.selectedShape = null;
                    this.clearControlPoints();
                    this.updateSelectionInfo();
                    this.render();
                }
            }
            
            newProject() {
                if (confirm('–°–æ–∑–¥–∞—Ç—å –Ω–æ–≤—ã–π –ø—Ä–æ–µ–∫—Ç?')) {
                    this.shapes = [];
                    this.selectedShape = null;
                    this.clearControlPoints();
                    this.updateSelectionInfo();
                    this.render();
                }
            }
            
            // –†–µ–Ω–¥–µ—Ä–∏–Ω–≥
            render() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // –†–µ–Ω–¥–µ—Ä–∏–º —Ñ–∏–≥—É—Ä—ã
                this.shapes.forEach(shape => {
                    this.drawShape(shape);
                });
                
                // –†–µ–Ω–¥–µ—Ä–∏–º —Ç–µ–∫—É—â—É—é —Ñ–∏–≥—É—Ä—É
                if (this.currentShape) {
                    this.drawShape(this.currentShape);
                }
                
                // –†–µ–Ω–¥–µ—Ä–∏–º –≤—ã–¥–µ–ª–µ–Ω–∏–µ
                if (this.selectedShape) {
                    this.drawSelection(this.selectedShape);
                }
            }
            
            drawShape(shape) {
                this.ctx.strokeStyle = shape.color;
                this.ctx.lineWidth = shape.strokeWidth;
                this.ctx.lineCap = 'round';
                this.ctx.lineJoin = 'round';
                
                switch (shape.type) {
                    case 'pen':
                        this.drawPen(shape);
                        break;
                    case 'line':
                        this.drawLine(shape);
                        break;
                    case 'rectangle':
                        this.drawRectangle(shape);
                        break;
                    case 'circle':
                        this.drawCircle(shape);
                        break;
                    case 'bezier':
                        this.drawBezier(shape);
                        break;
                }
            }
            
            drawPen(shape) {
                if (shape.points.length < 2) return;
                
                this.ctx.beginPath();
                this.ctx.moveTo(shape.points[0].x, shape.points[0].y);
                
                for (let i = 1; i < shape.points.length; i++) {
                    this.ctx.lineTo(shape.points[i].x, shape.points[i].y);
                }
                
                this.ctx.stroke();
            }
            
            drawLine(shape) {
                if (shape.points.length < 2) return;
                
                this.ctx.beginPath();
                this.ctx.moveTo(shape.points[0].x, shape.points[0].y);
                this.ctx.lineTo(shape.points[1].x, shape.points[1].y);
                this.ctx.stroke();
            }
            
            drawRectangle(shape) {
                this.ctx.strokeRect(shape.x, shape.y, shape.width, shape.height);
            }
            
            drawCircle(shape) {
                this.ctx.beginPath();
                this.ctx.arc(shape.x, shape.y, shape.radius, 0, 2 * Math.PI);
                this.ctx.stroke();
            }
            
            drawBezier(shape) {
                if (shape.points.length < 2) return;
                
                this.ctx.beginPath();
                this.ctx.moveTo(shape.points[0].x, shape.points[0].y);
                
                if (shape.controlPoints && shape.controlPoints.length >= 2) {
                    this.ctx.bezierCurveTo(
                        shape.controlPoints[0].x, shape.controlPoints[0].y,
                        shape.controlPoints[1].x, shape.controlPoints[1].y,
                        shape.points[1].x, shape.points[1].y
                    );
                } else {
                    this.ctx.lineTo(shape.points[1].x, shape.points[1].y);
                }
                
                this.ctx.stroke();
            }
            
            drawSelection(shape) {
                const bounds = this.getShapeBounds(shape);
                this.ctx.strokeStyle = '#00ffff';
                this.ctx.lineWidth = 1;
                this.ctx.setLineDash([5, 5]);
                this.ctx.strokeRect(bounds.x - 5, bounds.y - 5, bounds.width + 10, bounds.height + 10);
                this.ctx.setLineDash([]);
            }
            
            updateToolInfo() {
                const toolNames = {
                    'select': '–í—ã–¥–µ–ª–µ–Ω–∏–µ',
                    'move': '–ü–µ—Ä–µ–º–µ—â–µ–Ω–∏–µ',
                    'pen': '–ü–µ—Ä–æ',
                    'line': '–õ–∏–Ω–∏—è',
                    'rectangle': '–ü—Ä—è–º–æ—É–≥–æ–ª—å–Ω–∏–∫',
                    'circle': '–ö—Ä—É–≥',
                    'bezier': '–ö—Ä–∏–≤–∞—è –ë–µ–∑—å–µ',
                    'add-point': '–î–æ–±–∞–≤–∏—Ç—å —Ç–æ—á–∫—É',
                    'delete-point': '–£–¥–∞–ª–∏—Ç—å —Ç–æ—á–∫—É'
                };
                document.getElementById('toolInfo').textContent = toolNames[this.currentTool];
            }
            
            updateSelectionInfo() {
                document.getElementById('selectionInfo').textContent = 
                    this.selectedShape ? '–í—ã–¥–µ–ª–µ–Ω–æ' : '–ù–µ –≤—ã–¥–µ–ª–µ–Ω–æ';
            }
            
            updateCursorPos(e) {
                const pos = this.getPointerPos(e);
                document.getElementById('cursorPos').textContent = `X:${Math.round(pos.x)} Y:${Math.round(pos.y)}`;
            }
            
            // –§–∞–π–ª–æ–≤—ã–µ –æ–ø–µ—Ä–∞—Ü–∏–∏
            handleImageSelect(e) {
                // –ó–∞–≥–ª—É—à–∫–∞ –¥–ª—è –∑–∞–≥—Ä—É–∑–∫–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π
            }
            
            loadSelectedImage() {
                // –ó–∞–≥–ª—É—à–∫–∞
                this.hideModal('loadImageModal');
            }
            
            saveProject() {
                const project = {
                    shapes: this.shapes,
                    timestamp: new Date().toISOString()
                };
                
                const data = JSON.stringify(project, null, 2);
                const blob = new Blob([data], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                
                const a = document.createElement('a');
                a.href = url;
                a.download = 'vector-project.json';
                a.click();
                
                URL.revokeObjectURL(url);
            }
            
            showModal(modalId) {
                document.getElementById(modalId).style.display = 'flex';
            }
            
            hideModal(modalId) {
                document.getElementById(modalId).style.display = 'none';
            }
        }

        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è
        document.addEventListener('DOMContentLoaded', () => {
            new VectorEditor();
        });
    </script>
</body>
</html>